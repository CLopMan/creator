\chapter{Extensión V en RISC-V}\label{chap:v-extenssion}

En este capítulo se resume brevemente el conjunto de instrucciones vectoriales
de RISC-V con el fin de permitirle al lector comprender la totalidad de la
funcionalidad que esta soporta. Todo lo descrito en este capítulo se basa en el estándar~\cite{riscv-isa2024}.

\section{Parámetros constantes de arquitectura}

La arquitectura al completo depende de dos parámetros constantes: \textbf{VLEN} y \textbf{ELEN}.
\begin{itemize}
    \item \textbf{VLEN}: tamaño de un registro vectorial en bits. Está sujeto a la restricción de $VLEN \le 2^{16}$.
    \item \textbf{ELEN}: tamaño máximo de un elemento en bits. Está sujeto a la restricción de $ELEN = 2^i:\ i\le 3$.
\end{itemize}

Además, ambos parámetros deben cumplir la siguiente relación:

$$VLEN \ge ELEN$$

\section{Parámetros configurables}\label{conf-parameters}

Además de \textit{VLEN} y \textit{ELEN}, existen otros parámetros de arquitectura. A diferencia de los dos anteriores, estos son configurables por el programador:
\begin{itemize}
    \item\textbf{VSTART}: define el primer índice de un registro vectorial.
    \item\textbf{VL}: \textit{Vector Length}. Longitud de un registro vectorial.
    \item\textbf{SEW}: \textit{Selected Element Width}. Ancho de un elemento en bits. Su valor debe ser una potencia de 2. Actualmente se da soporte para $SEW\in \{8, 16, 32, 64\}$.
    \item\textbf{LMUL}: multiplicador para agrupar registros vectoriales. Su valor debe ser alguna de las siguientes potencias de dos, $LMUL \in \left\{\frac18,\frac14,\frac12, 1, 2, 4, 8\right\}$. Su funcionamiento se describe con mayor profundidad en la sección \ref{mapping-registers-with-lmul}.
    \item\textbf{VMA}: define el comportamiento de los elementos enmascarados. El comportamiento de los elementos enmascarados se tratará más adelante en la sección \ref{masked-and-tail-elements}.
    \item\textbf{VTA}: define el comportamiento de los elementos de cola. El comportamiento de los elementos de cola se tratará más adelante en la sección \ref{masked-and-tail-elements}.
\end{itemize}

Los parámetros VL y VSTART se almacenan en sus propios registros de control (Sección \ref{programmer-model}). Los parámetros SEW, LMUL, VMA y VTA se almacenan en un único registro de control VTYPE (Sección \ref{vtype-register}).

\subsubsection{VLMAX}\label{vlmax}
A partir de algunos de estos parámetros se define \textbf{VLMAX}, un parámetro con gran impacto sobre las instrucciones de configuración (Sección \ref{conf-instructions}). VLMAX describe la \textbf{máxima longitud de un vector} (es decir, el máximo número de elementos con los que puede operar una instrucción vectorial) dada una configuración de arquitectura.

$$VLMAX = LMUL \times \frac{VLEN}{SEW}$$

El valor máximo de VLMAX en una arquitectura se alcanza con $LMUL = SEW = 8$. Para una arquitectura de $VLEN = 128$ bits, el valor máximo de VLMAX se calcula de la siguiente forma: 

$$VLMAX = 8 \times \frac{128}{8} = 128~\text{elementos}$$

Dada la cota máxima sobre el parámetro VLEN, es evidente que VLMAX también cuenta con una cota máxima de $2^{16}$.

\section{Modelo del programador}\label{programmer-model}
La extensión V añade al conjunto de instrucciones básico de RISC-V 7 nuevos registros de control (Tabla \ref{control-regs}) y 32 registros vectoriales.

\begin{table}[H]
    \begin{tabular}{@{}ccl@{}}
        \toprule 
        Nombre & Privilegio & \phantom{~~~~~~~~~~~~~~~~}Descripción\\
        \midrule 
        vstart & URW\footnotemark[1] & vector start point\\
        vxsat  & URW & fixed-point saturate flag\\
        vxrm   & URW & fixed-point rounding mode\\
        vcsr   & URW & vector control and state register\\
        vl     & URO\footnotemark[2] & vector length\\
        vtype  & URO & vector data type register\\
        vlenb  & URO & vector lenght in bytes ($VLEN / 8$)\\
        \bottomrule 
    \end{tabular}
    \caption{Registros de control en risc V}
    \label{control-regs}
\end{table}

Los 32 nuevos registros vectoriales están numerados del 0 al 31. A cada uno de
ellos se le denomina v\{i\}, donde \{i\} se corresponde con el índice de
numeración. Estos registros tienen un ancho de VLEN bits.

\footnotetext[1]{Unprivilege read and write.}
\footnotetext[2]{Unprivilege read only.}

\subsection{El registro VTYPE}\label{vtype-register}

El registro VTYPE almacena el tipo de vector que se va a operar. Este viene determinado por los parámetros configurables descritos anteriormente (Sección \ref{conf-parameters}).

\begin{figure}[H]
\begin{scaletikzpicturetowidth}{\textwidth}
\begin{tikzpicture}[every node/.style={font=\ttfamily, scale=0.7}, , scale=\tikzscale]
    \draw[line width=0.2mm] (0,0) -- (20, 0) -- (20, 1) -- (0, 1) -- cycle;
    \draw (0.40, 1.2) node{31};
    \draw (0.40, 0.5) node{vill};
    \draw[line width=0.2mm](0.8, 1) -- (0.8, 0);
    \draw (1, 1.2) node{30};
    \draw (7.5, 0.5) node{reserved};
    \draw (14, 1.2) node{8};
    \draw[line width=0.2mm](14.25, 1) -- (14.25, 0);
    \draw (14.65, 1.2) node{7};
    \draw (14.65, 0.5) node{vma};
    \draw[line width=0.2mm](15.05, 1) -- (15.05, 0);
    \draw (15.45, 1.2) node{6};
    \draw (15.45, 0.5) node{vta};
    \draw[line width=0.2mm] (15.85, 1) -- (15.85, 0);
    \draw (16.1, 1.2) node{5};
    \draw (17, 0.5) node{vsew[2:0]};
    \draw (17.75, 1.2) node{3};
    \draw[line width=0.2mm] (18, 1) -- (18, 0);
    \draw (18.25, 1.2) node{2};
    \draw (19, 0.5) node{vlmul[2:0]};
    \draw (19.8, 1.2) node{0};
\end{tikzpicture}
\end{scaletikzpicturetowidth}
\caption {Formato del registro VTYPE}
\label{fig:vtype-reg-format}
\end{figure}

\subsubsection{El campo vill}
El campo vill contiene un único bit que indica si la configuración actual almacenada en VTYPE es válida o no. Este bit es consultado para cada acceso en VTYPE de forma que se lanza una excepción en caso de estar activo.

Esta forma de tratar el vector VTYPE permite el funcionamiento de programas con una configuración inconsistente de VTYPE, de forma que se levantará una excepción si y sólo si es necesario consultar alguno de los valores almacenados en este registro.

\subsubsection{Codificación de los campos vsew, vlmul, vma y vta}

Para codificar estos valores, es importante tener en cuenta que no se codifica directamente los valores en binario de los campos a los que se hace referencia. A continuación se adjuntan una serie de tablas para cada parámetro en las que se muestra la codificación de los distintos valores posibles:

\begin{table}[H]
    \begin{tabular}{@{}cc@{}}
    \toprule
    Codificación & Valor\\
    \midrule
    000 & 8\\
    001 & 16\\
    010 & 32\\
    011 & 64\\
    1XX & reservado\\
    \bottomrule
    \end{tabular}
    \caption{Codificación del campo vsew en VTYPE}
\end{table}

\begin{table}[H]
    \begin{tabular}{@{}cc@{}}
    \toprule
    Codificación & Valor\\
    \midrule
    100 & reservado\\
    101 & 1/8\\
    110 & 1/4\\
    111 & 1/2\\
    000 & 1\\
    001 & 2\\
    010 & 4\\
    011 & 8\\
    \bottomrule
    \end{tabular}
    \caption{Codificación del campo vlmul en VTYPE}
\end{table}

Destaca que vlmul se trata de un número codificado en complemento a 2 de forma que $LMUL = 2^{vlmul[2:0]}$.

\begin{table}[H]
    \begin{tabular}{@{}cccc@{}}
    \toprule
    vta & vma & Elementos de cola & Elementos inactivos\\
    \midrule
    0 & 0 & \textit{undisturbed} & \textit{undisturbed}\\
    0 & 1 & \textit{undisturbed} & \textit{agnostic}\\
    1 & 0 & \textit{agnostic} & \textit{undisturbed}\\
    1 & 1 & \textit{agnostic} & \textit{agnostic}\\
    \bottomrule
    \end{tabular}
    \caption{Codificación de los campos vma y vta  en VTYPE}
\end{table}


\subsection{Agrupamiento de registros vectoriales con LMUL}\label{mapping-registers-with-lmul}
Los registros vectoriales v0-v31 se agrupan de diferente forma según el valor
de LMUL. En caso de tener un valor fraccionario, parte de los registros queda
inutilizable (elementos de cola), mientras que para un LMUL entero se agrupan
los registros en grupos de LMUL integrantes de forma que se comportan como un
único registro vectorial. El grupo viene definido por el registro menor índice
y sólo serán accesibles aquellos registros cuyo índice sea múltiplo del valor
de LMUL\@.

\begin{table}[H]
    \begin{tabular}{@{}cccc@{}}
    \toprule
    LMUL & \# grupos & Registros agroupados & Registros accesibles\\
    \midrule
    1/8 & 32 & vn & v0, v1, \dots, v31\\
    1/4 & 32 & vn & v0, v1, \dots, v31\\
    1/2 & 32 & vn & v0, v1, \dots, v31\\
    1   & 32 & vn & v0, v1, \dots, v31\\
    2   & 16 & vn, vn + 1 & v0, v2, \dots, v30\\
    4   & 8  & vn, vn + 1, vn + 2, vn + 3 & v0, v4, \dots, v28\\
    8   & 4  & vn, vn + 1, \dots, vn + 7  & v0, v8, v16, v24\\
    \bottomrule
    \end{tabular}
    \caption{Grupos de registros según el valor de LMUL}
\end{table}

Para aquellos lectores familiarizados con MIPS I, el agrupamiento de vectores funciona de forma similar al tratamiento de los números de coma flotante de doble precisión en dicha arquitectura.


\subsection{Elementos inactivos y elementos de cola}\label{masked-and-tail-elements}
Los elementos inactivos se corresponden con posiciones en el registro que actúa como destino de una operación vectorial que, debido al uso de una máscara, no son operadas durante la ejecución de una instrucción. Los elementos de cola son posiciones en el registro destino cuyo índice es mayor o igual a VL, por lo que son elementos que tampoco serán operados durante la ejecución de una instrucción.

El comportamiento de estos elementos viene determinado por los valores de vma y vta en el registro VTYPE.
\begin{itemize}
    \item \textit{Undisturbed}: la posición mantiene el valor que tenía almacenado previamente a la ejecución de la instrucción.
    \item \textit{Agnostic}: no se garantiza que el valor previo a la ejecución de la instrucción se conserve.
\end{itemize}

\subsection{Mapeo de elementos en registros vectoriales}\label{subsec:mapping-vector-elements}

Los elementos en un registro vectorial se almacenan de forma continua tal que
los elementos de menor índice se correspondan con los bits menos significativos
del registro.

\subsubsection{Mapeo de elementos para LMUL = 1}
Los elementos se almacenan en orden desde los bits menos significativo hacia
los bits más significativos.

A continuación se muestra cómo se almacenarían el máximo número de elementos
para distintas configuraciones de SEW.

\begin{lstlisting}
Ejemplo con VLEN=128b, LMUL=1
Byte    F E D C B A 9 8 7 6 5 4 3 2 1 0

SEW=8b  F E D C B A 9 8 7 6 5 4 3 2 1 0
SEW=16b   7   6   5   4   3   2   1   0
SEW=32b       3       2       1       0
SEW=64b               1               0
\end{lstlisting}

\subsubsection{Mapeo de elementos para LMUL < 1}
El número de elementos usables del vector se corresponde con los primeros VLMAX
elementos. El resto de elementos serán tratados como elementos de cola
(Sección \ref{masked-and-tail-elements}).

A continuación se muestra como se almacenarían el máximo número de elementos
para distintas configuraciones de SEW.
\begin{lstlisting}
Ejemplo con VLEN=128b, LMUL=1/4
Byte    F E D C B A 9 8 7 6 5 4 3 2 1 0

SEW=8b  - - - - - - - - - - - - 3 2 1 0
SEW=16b - - - - - - - - - - - -   1   0
SEW=32b - - - - - - - - - - - -       0
SEW=64b - - - - - - - - - - - - - - - - configuración no válida
\end{lstlisting}


\subsubsection{Mapeo de elementos para LMUL > 1}
De forma similar al caso de LMUL=1, los elementos se almacenan de forma
continua comenzando en el registro vectorial de menor índice.

A continuación se muestra un ejemplo para un SEW, LMUL y VLEN fijos:
\begin{lstlisting}
Ejemplo con VLEN=128b, LMUL=4, SEW=32b
Byte    F E D C B A 9 8 7 6 5 4 3 2 1 0

v 4*n         3       2       1       0
v 4*n+1       7       6       5       4 
v 4*n+2       B       A       9       8
v 4*n+3       F       E       D       C 
\end{lstlisting}

\subsection{Registro de máscara}{\label{mask-reg}}
Las máscaras ocupan un único registro vectorial, independientemente de la
configuración de SEW y LMUL. Esta se conformará de los primeros $\lceil
VL/8\rceil$ bytes del registro de forma que la máscara para el elemento
\textit{i} de un vector se corresponde con el bit \textit{i} del registro de
máscara.

A continuación se muestra un ejemplo de como se recupera el
valor de un vector en función de si es tratado como máscara o no.

\begin{lstlisting}
Ejemplo de v0, VLEN = 64b, vl=8, SEW=8b, LMUL=1
Byte     7   6   5   4   3   2   1   0
Value   08  19  2A  3B  4C  5D  6E  7F

v0 = [127, 110, 93, 76, 59, 42, 25, 8]
v0.mask = [1, 1, 1, 1, 1, 1, 1, 0]
\end{lstlisting}

En la versión actual del estándar solo se permite usar como registro de máscara
v0. Sin embargo, se pueden almacenar valores de máscara en otros registros
(Sección \ref{sec:mask-operations}).

\tikzset{
  pics/mynode/.style args={}{
     code={
       \draw[fill=white!100] (0,0) -- (0, 0.5) -- (0.5, 0.25) -- cycle;
     }
  }
}
\begin{figure}[H]
\begin{tikzpicture}[every node/.style={font=\ttfamily, scale=0.7}]
    \node[] (ins) at (0, 1) {\large {vadd.vv v4 v2 v3 v0.t}};

    \draw (0, 0) -- (4, 0) node[midway, yshift=0.3cm]{v2} -- (4, 0.5) -- (0, 0.5) -- cycle;
    \draw (4, 0) -- (8, 0) node[midway, yshift=0.3cm]{v3}--  (8, 0.5) -- (4, 0.5) -- cycle;
    \draw (8, 0) -- (12, 0)node[midway, yshift=0.3cm]{v4}-- (12, 0.5) -- (8, 0.5) -- cycle;
    \foreach \i in {0,...,12} {
        \pgfmathtruncatemacro{\m}{int(mod(\i,4))}
        \ifnum\i<4
            \ifnum\i=2
                \draw[fill=red!30] (8 + \i*0.5, -5) rectangle (8 + \i*0.5 + 0.5, -5.5)  node[midway, yshift=0cm]{0};
            \else
                \draw[fill=mygreen!30] (8 + \i*0.5, -5) rectangle (8 + \i*0.5 + 0.5, -5.5)  node[midway, yshift=0cm]{1};
            \fi

            \draw[-stealth, thick] (8.25 + \i*0.5, -5) -- (8.25 + \i*0.5, -4.75 + 3*0.125 - 0.125*\i) 
            -- (8.25 +\i, -4.75 + 3*0.125 - 0.125*\i) 
            -- (\i + 8.25, -0.375*\i -0.375*4 - 0.065) 
            -- (\i + 8.425, -0.375*\i -0.375*4 - 0.065);
        \fi
        \ifnum\i<12
            \draw (\i, -0.5) rectangle (\i + 1, -1)  node[midway, yshift=0cm]{\m};
        \fi
        \ifnum\m=0
            \draw[dashed] (\i, 0) -- (\i, -0.5);
            \ifnum\i<12
                \draw[very thick] (\i, -0.5) rectangle (\i + 4, -1.0);
            \fi
        \fi
        \ifnum\i>3
            \ifnum\i<8
                \draw (\i + 0.5, 1.0 - 0.75*\i) circle (0.25);
                \draw (\i + 0.5, 1.0 - 0.75*\i) node{\textbf+};
                \draw[-stealth, thick] (\i-4 + 0.5, -1) to (\i - 3.5, 1.0 - 0.75*\i) to (\i + 0.25, 1.0 - 0.75*\i);
                \draw[-stealth, thick] (\i + 0.5, -1) to (\i + 0.5, 1.25 - 0.75*\i);
                \ifnum\i=6
                    \draw[-Rays, thick] (\i+4.5, -0.375*\i - 0.25) to (\i + 4.5, -1);
                \else
                    \draw[-stealth, thick] (\i+4.5, -0.375*\i - 0.25) to (\i + 4.5, -1);
                \fi
                \draw[thick] (\i + 0.75, 1 - 0.75*\i) to (\i + 4.5, 1 - 0.75*\i) to (\i+4.5, -0.375*\i - 0.25); 

                \draw (\i + 4.675, -0.375*\i - 0.25) pic[rotate=90]{mynode={}};

            \fi
        \fi
    }

    \draw (8, -6.25) -- (12, -6.25) node[midway, yshift=-0.3cm]{v0} -- (12, -6.75) -- (8, -6.75) -- cycle;
    \draw[dashed] (8, -5.5) -- (8, -6.25);
    \draw[dashed] (8.125, -6.25) -- (10, -5.5) node[right, yshift=0.4cm]{bit mask};
    \draw[thick] (8, -6.25) rectangle (8.125, -6.75);
\end{tikzpicture}

\caption {Diagrama de una suma vectorial con máscara}
\label{fig:masked-operation}
\end{figure}

\section{Instrucciones}
La extensión V de RISC-V añade 5 tipos de instrucciones, diviendo por funcionalidad:

\begin{itemize}
    \item Instrucciones de configuración: permiten modificar el registro VTYPE y los parámetros configurables de la arquitectura.
    \item Instrucciones de manejo de memoria: instrucciones \textit{load/store}.
    \item Instrucciones de aritmético-lógicas: operaciones lógicas y aritméticas entre vectores, entre vectores y valores inmediatos, y entre vectores y registros convencionales.
    \item Instrucciones de máscara: operaciones para operar con los elementos de registro vectorial con forma de máscara.
    \item Instrucciones de permutación: instrucciones para la copia o movimiento de elementos entre posiciones de un mismo vector o entre registros.
\end{itemize}

Además, cada instrucción cuenta con unos parámetros propios: \textbf{EEW} y \textbf{EMUL}.

\subsection{EEW vs SEW y LMUL vs EMUL}
Los parámetros EEW y EMUL tienen un significado similar a sus contrapartes SEW y LMUL (Sección \ref{conf-parameters}). Estos parámetros son propios de la instrucción, en lugar de ser compartidos por toda la arquitectura.
\begin{itemize}
    \item EEW: \textit{Effective Element Width}. El ancho de elemento en bits que utilizará la instrucción para operar.
    \item EMUL: \textit{Effective LMUL}. El factor de agrupamiento que utilizará la instrucción para operar.
\end{itemize}

Para muchas instrucciones, estos valores coincidirán su contraparte de la arquitectura. No obstante, en algunos casos serán distintos.

\subsection{Instrucciones de configuración}\label{conf-instructions}
Estas instrucciones permiten modificar los valores almacenados en VL y VTYPE.

\begin{lstlisting}
vsetvli rd, rs1, vtypei   # rd=new vl,rs1=AVL,vtypei=new VTYPE
vsetivli rd, uimm, vtypei # rd=new vl,uimn=AVL,vtypei=new VTYPE
vsetvl  rd, rs1, rs2      # rd=new vl,rs1=AVL,rs2=new VTYPE
\end{lstlisting}

Observando los argumentos individualmente:
\begin{itemize}
    \item rd: registro que almacenará el nuevo valor de VL.
    \item AVL: \textit{App Vector Length}. Propuesta de VL.
    \item vtypei: nuevo valor del registro VTYPE. Es un valor inmediato caracterizado por varios argumentos enumerados.
\end{itemize}

\subsubsection{vtypei}
La representación de \texttt{vtypei} es libre. No obstante, el estándar sugiere
los siguientes nombres para representarlo:

\begin{lstlisting}
e8  # SEW=8b   
e16 # SEW=16b
e32 # SEW=32b
e64 # SEW=64b

mf8 # LMUL=1/8
mf4 # LMUL=1/4
mf2 # LMUL=1/2
m1  # LMUL=1
m2  # LMUL=2
m4  # LMUL=4
m8  # LMUL=8

ma  # mask agnostic (vma=1)
mu  # mask undisturbed (vma=0)
ta  # tail agnostic (vta=1)
tu  # tail undisturbed (vta=0)
\end{lstlisting}

Si el valor codificado en \texttt{vtypei} no es una configuración permitida, el
campo \texttt{vill} de VTYPE será establecido a 1, mientras que en el registro
VL se escribirá un 0.

\subsubsection{Restricciones sobre la actualización de VL}
Para acutalizar VL se establece una propuesta (AVL) en un registro y la
arquitectura establecerá el nuevo valor de VL en base a una serie de
restricciones. Estas restricciones se pueden resumir en una para casos
genéricos donde $AVL \ge 0$.

$$VL = \min(VLMAX, AVL)$$

Esta restricción se deriva de lo expuesto en la sección 31.6.3 de \cite{riscv-isa2024}.

\subsection{Instrucciones de memoria}
Las instrucciones de memoria permiten la carga y lectura de vectores en memoria.

\subsubsection{Load y Store Unit-Stride}
Estas instrucciones permiten leer o escribir VL elementos contiguos con un
ancho de elemento (EEW)  especificado en la instrucción.

\begin{lstlisting}
# formato
vle<eew>.v vd, (rs1)[, vm] # vd[i] = mem[rsi + eew*i/8]
vse<eew>.v vd, (rs1)[, vm] # vd[i] = mem[rsi + eew*i/8]
\end{lstlisting}

Las instrucciones de tipo \textit{load} cuentan además con una versión
\textit{fault-only-first}. Estas se comportan igual, con la diferencia de que
sólo levantarán una excepción en caso de ocurrir un error durante el primer
acceso a memoria, exclusivamente.

\begin{lstlisting}
# formato
vle<eew>ff.v vd, (rs1)[, vm] # vd[i] = mem[rsi + eew*i]
\end{lstlisting}

Adicionalmente, se añade una instrucción para la lectura y almacenamiento de
máscaras. Esta se comporta igual que \texttt{vle8.v} y \texttt{vse8.v} con la
excepción de que tratará con $\lceil VL / 8\rceil$ elementos en lugar de VL.

\begin{lstlisting}
vlm.v vd, (rs1)
vsm.v vd, (rs1)
\end{lstlisting}

\subsubsection{Load y Store Strided}
Permiten la carga y descarga de memoria no contiguos en memoria con un paso o
\textit{stride} especificado en la propia instrucción. El paso debe
especificarse en \textit{bytes}.

\begin{lstlisting}
#formato
vlse<eew>.v vd, (rs1), rs2[, vm] # vd[i] = mem[rs1 + i*rs2]
vsse<eew>.v vd, (rs1), rs2[, vm] # mem[rs1 + i*rs2] = vd[i]
\end{lstlisting}

Estas instrucciones pueden ser útiles en el manejo de estructuras de datos. Por
ejemplo, supongamos que tenemos en la dirección \texttt{img} un conjunto de 9
píxeles continuos en memoria representados con sus valores RGB.

\begin{lstlisting}

# img: r0, g0, b0, r1, g1, b1, ..., r8, g8, b8

la a1, img
li a0, 9

vsetvli t0, a0, e8, m1, ma, ta # SEW=8b, vl=9, LMUL=1

vlse8.v v0, (a1), 3 # En v0 queda almacenado el canal RED

\end{lstlisting}

De esta forma en v0 se almacena el canal correspondiente al rojo de forma que
se puede operar con ese canal por separado.

\subsubsection{Operaciones Load y Store indexadas}
Estas instrucciones permiten el almacenamiento en posiciones arbitrarias de un vector.

\begin{lstlisting}
#formato
vluxei<eew>.v vd, (rs1), vs2[, vm] # vd[vs2[i]] = mem[i]
                                   # (ordered)
vloxei<eew>.v vd, (rs1), vs2[, vm] # (unordered)
vsuxei<eew>.v vd, (rs1), vs2[, vm] # mem[rs1 + i*vs2[i]] = vd[i] 
                                   # (ordered)
vsoxei<eew>.v vd, (rs1), vs2[, vm] #(unordered)
\end{lstlisting}

La diferencia entre las operaciones ordenadas y desordenadas es que las
primeras garantizan el tratamiento de los elementos en orden de posición,
mientras que las segundas no.

\subsubsection{Load y Stored segmentadas}
Estas instrucciones son versiones de las anteriores que operan sobre múltiples
registros a la vez. Estas ignoran LMUL y operan con un EMUL indicado como
argumento.

\begin{lstlisting}
#formato
# Unit-stride
vlseg<emul>e<eew>.v vd, (rs1)[, vm] 
    # vd[i] = mem[rs1 + i*emul*eew/8] 
    # vd+1[i] = mem[rs1 + eew + i*emul*eew/8]
    # vd+emul-1[i] = mem[rs1 + emul-1 + (emul-1)*i*eew/8]

vsseg<emul>e<eew>.v vd, (rs1)[, vm]
    # mem[rs1 + i*emul*eew/8] = vd[i]
    # mem[rs1 + eew + i*emul*eew/8] = vd+1[i]
    # mem[rs1 + emul-1 + (emul-1)*i*eew/8] = vd+emul-1[i]

#fault only first
vlseg<emul>e<eew>ff.v vd, (rs1)[, vm]

# strided
vlsseg<emul>e<eew>.v vd, (rs1), rs2[, vm]
    # vd[i] = mem[rs1 + i*emul*eew/8] 
    # vd+1[i] = mem[rs1 + eew + i*emul*eew/8]
    # vd+emul-1[i] = mem[rs1 + emul-1 + emul-1*i*eew/8]

vssseg<emul>e<eew>.v vd, (rs1), rs2[, vm]
    # mem[rs1 + i*emul*eew/8] = vd[i]                   
    # mem[rs1 + eew + i*emul*eew/8] = vd+1[i]
    # mem[rs1 + emul-1 + emul-1*i*eew/8] = vd+emul-1[i]

# indexadas
vluxseg<emul>ei<eew>.v vd, (rs1), vs2, vm
    # vd[vs2[0 + emul*i]] = mem[rs1 + i*emul*eew/8]
    # vd+1[vs2[1 + emul*i]] = mem[rs1 + eew + i*emul*eew/8]
    # vd+emul-1[vs2[emul-1 + emul*i]] = mem[rs1 + emul-1 + (emul-1)*eew + i*emul*eew/8]
vloxseg<emul>ei<eew>.v vd, (rs1), vs2, vm
vsuxseg<emul>ei<eew>.v vd, (rs1), vs2, vm
    # mem[rs1 + i*emul*eew/8] = vd[vs2[0 + emul*i]]
    # mem[rs1 + eew + i*emul*eew/8] = vd+1[vs2[1 + emul*i]]
    # mem[rs1 + emul-1 + (emul-1)*eew + i*emul*eew/8] =  vd+emul-1[vs2[emul-1 + emul*i]]
vsoxseg<emul>ei<eew>.v vd, (rs1), vs2, vm

\end{lstlisting}

Estas instrucciones permiten el manejo de estructuras de datos complejas,
permitiendo separar en registros diferentes los campos del mismo tipo. Por
ejemplo, el siguiente programa suma dos vectores de números complejos,
separando su parte real e imaginaria.

\begin{lstlisting}
# suma de números complejos
# VLEN=256b

la a1, complex1
la a2, complex2

li a0, 8 
vsetlvi.v t0 a0 e32 m1 mu tu

vlsseg2e32.v v2, (a1), t1
vlsseg2e32.v v4, (a2), t1

vfadd.vv v7, v3, v5 # parte imaginaria
vfadd.vv v6, v3, v2 # parte real
\end{lstlisting}


\subsubsection{Load y Stored sobre registros completos}
Estas instrucciones permiten cargar y restaurar registros vectoriales
completos cuando no se conocen ni el valor de VTYPE ni el valor VL del
contenido. Al igual que las instrucciones segmentadas, permiten la
actualización de varios registros vectoriales con una misma instrucción.

\begin{lstlisting}
    vl<emul>re<eew>.v vd, (rs1)
        vl<emul>re8.v vd, (rs1) # carga emul registros con vlen/8 bytes
        vl<emul>re16.v vd, (rs1) # carga emul registros con vlen/16 medias palabras
        vl<emul>re32.v vd, (rs1) # carga emul registros con vlen/32 palabras
        vl<emul>re64.v vd, (rs1) # carga emul registros con vlen/64 dobles palabras

    vs<emul>r.v vd, (rs1) # almacena en mem[rs1] EMUL*VLEN/8 bytes
\end{lstlisting}

Las instrucciones de tipo \textit{load} están preparadas para operar en
máquinas con un tamaño de palabra arbitrario. Sin embargo, para un ordenador
con ancho de palabra de 32 bits, la instrucción carga la misma cantidad de
información para cualquier EEW.

\subsection{Instrucciones aritmético-lógicas}

Las operaciones aritmético-lógicas reciben generalmente 3 argumentos: el vector
destinatario de la operación (vd), un operando vectorial (vs1) y un segundo
operando cuya naturaleza puede variar entre otro vector (vs2), un valor
inmediato (inm), o un escalar almacenado en otro registro (rs1). Además, las
operaciones están separadas por aritmética entera, aritmética de punto fijo y
aritmética en coma flotante. Las instrucciones indican el tipo de operandos que
usan según la extensión de la instrucción.

\begin{lstlisting}
# aritmética entera
vop.vv vd, vs2, vs1[, vm]
vop.vx vd, vs2, rs1[, vm]
vop.vi vd, vs2, inm[, vm]

# aritmética en coma flotante
vfop.vv vd, vs2, vs1[, vm]
vfop.vx vd, vs2, rs1[, vm]
vfop.vi vd, vs2, inm[, vm]
\end{lstlisting}

Dado que la aritmética de punto fijo coincide con la aritmética entera, emplean
el mismo tipo de operaciones. Es por esto que no existe un formato exclusivo
para las instrucciones de punto fijo, sino una breve extensión sobre el
conjunto de aritmética entera.

\subsubsection{Instrucciones \textit{widening} y \textit{narrowing}}
Estas instrucciones operan modificando la precisión de los operandos.

Las instrucciones \textit{widening}, o de ensanchado, duplican la precisión del
vector destinatario (vd) con respecto a los operandos de forma
que $EEW_{vd} = 2\times EEW_{vs*} = 2\times SEW$ y $EMUL_{vd} = 2\times
EMUL_{vs*} = 2\times LMUL$. Además, se puede duplicar la precisión del primer
operando de la misma forma indicándolo con el sufijo \texttt{w} ($EEW_{vs2} = 2\times SEW$).

Las instrucciones de \textit{narrowing}, o estrechamiento, duplican la
precisión uno de los operandos y mantienen la precisión del vector destino
de forma que $2\times EEW_{vd} = EEW_{vs2} = 2\times SEW$ y $2\times
EMUL_{vd} = EMUL_{vs2} = 2*LMUL$. El operando de doble precisión se debe
colocar el primero, y es indicado por el sufijo \texttt{w}. 

Estas instrucciones no admiten el uso de operandos inmediatos.

\begin{lstlisting}
# widening
v[f]wop.vv vd, vs2, vs1[, vm] # EEW(vd) = 2*EEW(vs2) = 2*SEW
v[f]wop.vx vd, vs2, rs1[, vm] # EEW(vd) = 2*EEW(vs2) = 2*SEW
v[f]wop.wv vd, vs2, vs1[, vm] # EEW(vd) = EEW(vs2) = 2*SEW
v[f]wop.wx vd, vs2, rs1[, vm] # EEW(vd) = EEW(vs2) = 2*SEW
                       
# narrowing            
v[f]nop.wv vd, vs2, vs1[, vm] # 2*EEW(vd) = EEW(vs2) = 2*SEW
v[f]nop.wx vd, vs2, rs1[, vm]
\end{lstlisting}

\subsubsection{Aritmética entera}{\label{sec:int-operations}}

Las instrucciones para enteros incluyen distintas operaciones, extensión de
signo, multiplicación acumulativa, comparación, desplazamiento y operaciones de copia y
modificación de valores. Las operaciones y multiplicación acumulativa también
cuentan con versiones \textit{widening} y \textit{narrowing}.

Las operaciones a las que se dan soporte son la suma, resta, resta inversa,
multiplicación y división. Siguiendo los formatos explicandos con anterioridad,
se incluyen las operaciones convencionales y de ensanchado y estrechamiento.
Adicionalmente, algunas cuentan con la capacidad de operar con números sin
signo. Las operaciones de suma y resta cuentan con una variación para operar
con acarreo; la multiplicación permite seleccionar si, en caso de
desbordamiento, se almacenarán los bits más significativos o menos
significativos; y la división cuenta con soporte para extraer el resto con
signo o sin signo.

Alugnos ejemplos del formato de estas instrucciones son:

\begin{lstlisting}
# suma y resta
vadd.v* vd, vs1, [v|r]s2[, vm]
vwadd[u].v* dv, vs1 [v|r]s2[, vm]
vsub vd, vs1, [v|r]s2[, vm]
vwsub[u].v* dv, vs1 [v|r]s2[, vm]

# resta inversa
vrsub.vx vd, vs2, rs1[, vm] # vd[i] = rs1 - vs2[i]
vrsub.vi vd, vs2, imm[, vm]

# suma con acarreo
vadc.v*m vd, vs2, vs1, v0
vmadc.v*m vd, vs2, vs1[, v0]

# multiplicación y división
vmul.v* vd, vs2, vs1[, vm] # retorna los bits menos significativos
vwmul.v* vd, vs2, vs1[, vm]
vmulh.v* vd, vs2, vs1[, vm] # retorna los bits más significativos
vmulhsu.v* vd, vs2, vs1[, vm] # signed-unsigned

vdiv.v* vd, vs2, vs1[, vm]  # signed
vdivu.v* vd, vs2, vs1[, vm] # unsigned
vremu.v* vd, vs2, vs1[, vm] # resto unsigned
vrem.v* vd, vs2, vs1[, vm]  # resto signed

\end{lstlisting}

Las operaciones de extensión te permiten extender el signo o extender con 0's
hasta un ancho determinado por SEW asumiendo un vector origen con $EEE =
SEW/N$, donde $N$ es un argumento de la instrucción.

\begin{lstlisting}
vzext.vf<N> vd, vs1[, vm] # extensión con 0's
vsext.vf<N> vd, vs1[, vm] # extensión de signo
\end{lstlisting}

La multiplicación acumulativa permite operar con 3 operandos mediante la
fórmula $vd[i] = \pm(op1 \times op2) + vd[i]$. A continuación se muestran
algunos formatos de esta clase de instrucciones.

\begin{lstlisting}
vmacc.v* vd [v|r]s1, vs2[, vm] # vd = +(vs1*vs2)+vd
vnmacc.v* vd [v|r]s1, vs2[, vm]# vd = -(vs1*vs2)+vd

vwmacc.v* vd [v|r]s1, vs2[, vm] # signed-integer
vwmaccu.v* vd [v|r]s1, vs2[, vm] # unsigned-integer
vwmaccsu.v* vd [v|r]s1, vs2[, vm] # signed-unsigned
vwmaccus.v* vd [v|r]s1, vs2[, vm] # unsigned-signed
\end{lstlisting}

Las instrucciones \texttt{merge} y \texttt{mv} permiten el traspaso de datos
desde un registro vectorial a otro.  La operación \texttt{merge} permite
combinar los valores de dos registros vectoriales en un tercero según el valor
de la máscara almacenada en v0. La operación \texttt{mv} permite copiar valores
en otro registro vectorial.

\begin{lstlisting}
vmerge.vvm vd, vs2, vs1, v0 # vd[i] = v0[i] ? vs2[i] : vs1[i]
vmerge.vxm vd, vs2, rs1, v0 # vd[i] = v0[i] ? vs2[i] : rs1
vmerge.vim vd, vs2, inm, v0 # vd[i] = v0[i] ? vs2[i] : inm

vmv.v.v vd, vs1 # vd[i] = vs1[i]
vmv.v.x vd, rs1 # vd[i] = rs1
vmv.v.i vd, inm # vd[i] = inm
\end{lstlisting}

Las operaciones de comparación dan soporte a distintas operaciones del tipo
\textit{set-if} donde se dará una signación de un valor binario (0 ó 1) si se
cumple una condición. A continuación se muestran algunos ejemplos de esta clase
de instrucciones. El registro destino de esta operación será tratado como una
máscara (Sección \ref{sec:mask-operations}).

\begin{lstlisting}
vmseq.vv vd, vs1, vs2[, vm] # set if equal
vmsne.vi vd, vs1, inm[, vm] # set if not equal
vmslt.vx vd, vs1, inm[, vm] # set if less than
vmsltu.vi vd, vs1, inm[, vm] # set if less than unsigned
vmsle.vv vd, vs1, vs2[, vm] # set if less or equal
vmsgt.vv vd, vs1, vs2[, vm] # set if greater than
vmsgtu.vx vd, vs1, rs1[, vm] # set if greater or equal
\end{lstlisting}

Las instrucciones máximo y mínimo asignan el valor más alto o bajo,
respectivamente, a un vector destino comparando dos vectores. Estas
instrucciones cuentan con versiones con signo y sin signo.

\begin{lstlisting}
vminu.vv vd vs1 vs2[, vm] # vd[i] = min(vs1[i], vs2[i])
vminu.vx vd rs1 vs2[, vm] # vd[i] = min(rs1, vs2[i])

vmin.vv vd vs1 vs2[, vm]
vmin.vx vd rs1 vs2[, vm]

vmaxu.vv vd vs1 vs2[, vm]
vmaxu.vx vd rs1 vs2[, vm]

vmax.vv vd vs1 vs2[, vm]
vmax.vx vd rs1 vs2[, vm]
\end{lstlisting}

Por último, las instrucciones de desplazamiento soportan tanto un
desplazamiento lógico hacia la izquierda como aritmético y lógico hacia la
derecha. El valor de desplazamiento puede ser un
vector, un registro entero o un valor inmediato sin signo.

\begin{lstlisting}
vsrl.vv vd, vs2, vs1[, vm] # shift lógico
vsrl.vx vd, vs2, rs1[, vm] 
vsra.vi vd, vs2, inm[, vm] # shift aritmético

vnsrl.vv vd, vs2, vs1[, vm] # narrowing shift
\end{lstlisting}


\subsubsection{Operaciones lógicas}

La especificación de instrucciones describe el comportamiento de 3 operaciones:
\textit{and, or} y \textit{xor}. Las tres operaciones operan a nivel de bit y
permiten usar como segundo operando un vector, valor inmediato o un registro
entero.

\begin{lstlisting}
vand.vv vd, vs2, vs1, vm

vor.vv vd, vs2, vs1, vm

vxor.vv vd, vs2, vs1, vm
\end{lstlisting}

\subsubsection{Aritmética de punto fijo}

La especificación da soporte a varias operaciones similares a la aritmética
entera. Estas instrucciones dependen fuertemente de los registros \texttt{vxrm}
y \texttt{vxsat}. La principal diferencia es la posibilidad de saturar el
resultado.

\begin{lstlisting}
vsaddu.v* vd, vs2, vs1[, vm] # add saturado sin signo
vsadd.v* vd, vs2, vs1[, vm] # add saturado con signo

vaaddu.v* vd, vs2, vs1[, vm] # add no saturado sin signo
vaadd.v* vd, vs2, vs1[, vm] # add no saturado con signo

vssubu.v* vd, vs2, vs1[, vm] # sub saturado sin signo
vssub.v* vd, vs2, vs1[, vm] # sub saturado con signo

vasubu.v* vd, vs2, vs1[, vm] # add no saturado sin signo
vasub.v* vd, vs2, vs1[, vm] # add no saturado con signo

vsmul.v* vd, vs2, vs1[, vm] # multiplicación

\end{lstlisting}

Además, se da soporte a otras dos instrucciones para el desplazamiento hacia la
derecha (tanto aritmético como lógico).
\begin{lstlisting}
vssrl.v* vd, vs2, vs1[, vm] # desplazamiento lógico
vssra.v* vd, vs2, vs1[, vm] # desplazamiento aritmético
\end{lstlisting}

También se da soporte a la reducción del número de bits usados por elemento.
Estas instrucciones emplean el indicativo de tipo de operando para indicar cuál
de los dos usa una mayor precisión:
\begin{itemize}
\item \texttt{w}: operando vectorial de mayor precisión (\texttt{2*SEW}).
\item \texttt{v}: operando de vectorial de menor precisión (\texttt{SEW}).
\item \texttt{x}: operando de entero (registro) de menor precisión (\texttt{SEW}).
\item \texttt{i}: operando de entero (inmediato) de menor precisión (\texttt{SEW}).
\end{itemize}

\begin{lstlisting}
vnclip.wv vd, vs2, vs1[, vm] # signed
vnclipu.wv vd, vs2, vs1[, vm] # unsigned

vnclip.wx vd, vs2, rs1[, vm] # signed
vnclipu.wx vd, vs2, rs1[, vm] # unsigned

vnclip.wi vd, vs2, inm[, vm] # signed
vnclipu.wi vd, vs2, uinm[, vm] # unsigned
\end{lstlisting}

\subsubsection{Aritmética de coma flotante}
La especificación da soporte a las mismas operaciones que para la aritmética
entera, en este caso utilizando el prefijo \texttt{vf}. Además, estas
instrucciones no soportan el uso de valores inmediatos como operandos. Para
extraer un valor de un registro en coma flotante se debe usar el sufijo
\texttt{f}.

Además de las operaciones suma, resta, multiplicación, división, de
comparación, máximo, mínimo, \textit{multiply-add}, \textit{move} y
\textit{merge} (equivalentes a las descritas en la sección
\ref{sec:int-operations}); se da soporte a nuevas operaciones.

\begin{lstlisting}
vfsqrt.v vd, vs2[, vm]   # vd[i] = sqrt(vs2[i])
vfrsqrt7.v vd, vs2[, vm] # vd[i] = 1/sqrt(vs2[i])
vfrec7.v vd, vs2[, vm]   # vd[i] = 1/vs2[i]

vfsgnj.vv vd, vs2, vs1[, vm] # vd[i]=abs(vs2[i]) with sign of vs1[i]
vfsgnj.vv vd, vs2, vs1[, vm]
vfsgnjn.vv vd, vs2, vs1[, vm] # vd[i]=abs(vs2[i]) with sign of not vs1[i]
vfsgnjn.vf vd, vs2, rs1[, vm]
vfsgnjx.vf vd, vs2, rs1[, vm] # vd[i]=abs(vs2[i]) with sign of sign(vs2[i]) xor sign(vs1[i])
vfsgnjx.vf vd, vs2, rs1[, vm]

# clasifica en las clases {NaN, -inf, positivo, negativo, -0, +0, inf}
vfclass.v vd, vs2[, vm] 

vfcvt.xu.f.v vd, vs2[, vm] # vd[i] = unsigned(float(vs2[i]))
vfcvt.x.f.v vd, vs2[, vm] # vd[i] = signed(float(vs2[i]))

vfcvt.rtz.xu.f.v vd, vs2[, vm] # vd[i] = unsigned(float(vs2[i])) double width
vfcvt.rtz.x.f.v vd, vs2[, vm] # vd[i] = signed(float(vs2[i])) double width

vfcvt.f.xu.v vd, vs2[, vm] # vd[i] = float(unsigned(vs2[i])
vfcvt.f.x.v vd, vs2[, vm] # vd[i] = float(signed(vs2[i]))
\end{lstlisting}

\subsection{Operaciones de reducción}
Las instrucciones de reducción aplican un operador binario a todos los elementos de un vector, guardando el resultado en la pimera posición. Estas pueden operar conn valores enteros o en coma flotante.

\begin{lstlisting}
# enteros
vredsum.vs  vd, vs2, vs1[, vm]   # vd[0] =  sum(vs1[0], vs2[*])
vredmaxu.vs vd, vs2, vs1[, vm]   # vd[0] = maxu(vs1[0], vs2[*])
vredmax.vs  vd, vs2, vs1[, vm]   # vd[0] =  max(vs1[0], vs2[*])
vredminu.vs vd, vs2, vs1[, vm]   # vd[0] = minu(vs1[0], vs2[*])
vredmin.vs  vd, vs2, vs1[, vm]   # vd[0] =  min(vs1[0], vs2[*])
vredand.vs  vd, vs2, vs1[, vm]   # vd[0] =  and(vs1[0], vs2[*])
vredor.vs   vd, vs2, vs1[, vm]   # vd[0] =   or(vs1[0], vs2[*])
vredxor.vs  vd, vs2, vs1[, vm]   # vd[0] =  xor(vs1[0], vs2[*])

# coma flotante
vfredosum.vs vd, vs2, vs1[, vm]
vfredusum.vs vd, vs2, vs1[, vm]
vfredmax.vs  vd, vs2, vs1[, vm]
vfredmin.vs  vd, vs2, vs1[, vm]
\end{lstlisting}
Para la operación suma existen también variantes \textit{widening} que permiten
extender con 0's los valores hasta un ancho de \texttt{2*SEW}, almacenando el
resultado en un elemento del mismo ancho.

\subsection{Instrucciones de máscara}{\label{sec:mask-operations}}
Este conjunto de instrucciones son similares a las instrucciones de aritmética
entera, con la excepción de que emplean un único registro vectorial
independientemente de la configuración de \textit{LMUL}. Además, los registros
vectoriales serán tratados como una máscara (Sección \ref{mask-reg}). Es decir,
usarán una longitud $l = \lceil VL/8 \rceil$ y cada elemento tendrá un
\texttt{EEW=1b}. 

Se da soporte a diversas operaciones que emplean máscaras como operandos. Estas se exponen a continuación. 

\begin{lstlisting}
# operaciones lógicas
vmand.mm vd, vs2, vs1  # vd.mask[i] = vs2.mask[i] && vs1.mask[i] 
vmnand.mm vd, vs2, vs1 # vd.mask[i] = !(vs2.mask[i] && vs1.mask[i])
vmandn.mm vd, vs2, vs1 # vd.mask[i] = vs2.mask[i] && !vs1.mask[i]
vmxor.mm vd, vs2, vs1  # vd.mask[i] = vs2.mask[i] ^^ !vs1.mask[i]
vmor.mm vd, vs2, vs1   # vd.mask[i] = vs2.mask[i] || !vs1.mask[i]
vmnor.mm vd, vs2, vs1  # vd.mask[i] = !(vs2.mask[i] || !vs1.mask[i])
vmxnor.mm vd, vs2, vs1 # vd.mask[i] = !(vs2.mask[i] ^^ !vs1.mask[i])

# conteo de elementos activos
vcpop.m rd, vs2[, vm]  # rd = sum(vs2.mask[i] [&& v0.mask[i]])

# find-first-set bit 
vfirst.m rd, vs2[, vm]

# set-before-first, set-including-first, set-only-first
vmsbf.m vd, vs2[, vm]
vmsif.m vd, vs2[, vm]
vmsof.m vd, vs2[, vm]

# conteo acumulativo de elementos activos
viota.m, vd, vs2[, vm]

# extracción de índices
vid.v vd[, vm] # vd[i] = i & v0.mask[i]
\end{lstlisting}

A continuación se muestra una implementación de la función \texttt{strcpy}~\cite{strcpy} empleando las instrucciones de máscara. Este código ha sido extraído de~\cite{riscv-isa2024}.

\begin{lstlisting}
.text
.balign 4
.global strcpy

# char* strcpy(char *dst, const char* src)
strcpy:
      mv a2, a0             # Copy dst
      li t0, -1             # Infinite AVL
loop:
    vsetvli x0, t0, e8, m8, ta, ma  # Max length vectors of bytes
    vle8ff.v v8, (a1)      # Get src bytes
    csrr t1, vl            # Get number of bytes fetched
    vmseq.vi v1, v8, 0     # Flag zero bytes
    vfirst.m a3, v1        # Zero found?
    add a1, a1, t1         # Bump pointer
    vmsif.m v0, v1         # Set mask up to and including zero byte.
    vse8.v v8, (a2), v0.t  # Write out bytes
    add a2, a2, t1         # Bump pointer
    bltz a3, loop          # Zero byte not found, so loop

    ret
\end{lstlisting}

\subsection{Permutaciones}
Las instrucciones de permutación permiten mover elementos dentro de un mismo
vector. Estas incluyen instrucciones \textit{move}, instrucciones
\textit{slide}, instrucciones \textit{gather} e instrucciones
\textit{compress}.

Las instrucciones \textit{move} permiten la copia de un valor entre un registro
convencional (flotante o entero) y el valor \texttt{vi[0]} de un vector. La
copia puede ser en los dos sentidos dependiendo del sufijo de la instrucción.
Además, también permiten la copia de registros vectoriales completos.

\begin{lstlisting}
# registros de enteros
vmv.x.s rd, vs2  # rd <= vs2[0]
vmv.s.x vs2, rs1 # vs2[0] <= rs1

# Registros de coma flotante
vfmv.x.s rd, vs2  # rd <= vs2[0]
vfmv.s.x vs2, rs1 # vs2[0] <= rs1

# Registros vectoriales completos
vmv<nr>r.v vd, vs2 # vd = vs2, vd+1 = vs2+1,..., vd+nr-1 = vs2+nr-1
                   # nr in (1, 2, 4, 8)
vmv4r.v v4, v8 # v4 = v8 
               # v5 = v9
               # v6 = v10
               # v7 = v11
\end{lstlisting}

Las instrucciones \textit{slide} mueven elementos de un vector. Estas instrucciones
actúan como un desplazamiento dentro del vector. Existen variantes que además
permiten insertar un elemento proveniente de un registro de enteros o en coma
flotante.

\begin{lstlisting}
# Desplazamientos
vslideup.vx vd, vs2, rs1[, vm] # vd[i + rs1] = vs2[i]
vslideup.vi vd, vs2, uinm[, vm] # vd[i + uinm] = vs2[i]
vslidedown.vx vd, vs2, rs1[, vm] # vd[i] = vs2[i + rs1]
vslidedown.vi vd, vs2, uinm[, vm] # vd[i] = vs2[i + uinm]

# Desplazamiento con inserción
v[f]slide1up.vx vd, vs2, rs1[, vm] # vd[i + 1] = vs2[i], vd[0] = rs1
v[f]slide1down.vx vd, vs2, rs1[, vm] # vd[i] = vs2[i + 1], vd[vl-1] = rs1
\end{lstlisting}

Las instrucciones \textit{gather} permiten la copia de elementos arbitrarios de
un vector a otro, donde los índices a trasladar estarán controlados por un
segundo vector. En caso de que el índice esté fuera de rango ($index \ge
VLMAX$), se escribirá un 0. Los elementos cuyo índice sean supererioes a
\texttt{VL} serán manejados siguiendo el comportamiento de los elementos de
cola descritos en la sección~\ref{masked-and-tail-elements}.

\begin{lstlisting}
vrgather.vv vd,vs2, vs1[, vm]  # vd[i] = (vs1[i] >= VLMAX)? 0 : vs2[vs1[i]]
vrgather.vx vd,vs2, rs1[, vm]  # vd[i] = (rs1 >= VLMAX)? 0 : vs2[vs1[i]]
vrgather.vi vd,vs2, uinm[, vm] # vd[i] = (uinm >= VLMAX)? 0 : vs2[vs1[i]]
# EEW=16b para vs1
vrgatherei16.vv vd,vs2, vs1[, vm] # vd[i] = (vs1[i] >= VLMAX)? 0 : vs2[vs1[i]]
\end{lstlisting}

Por último, la instrucción \textit{compress} agrupa los valores activos
(Sección \ref{masked-and-tail-elements}) de un vector. En esta instrucción se puede
usar cualquier registro vectorial como máscara, en lugar de v0.

\begin{lstlisting}
vcompress.vm vd, vs2, vs1
\end{lstlisting}

\section{Resumen}
Este capítulo ha presentado de forma breve la especificación de la extensión V de la arquitectura RISC-V, aprobada en 2021 y publicada en la especificación oficial de 2024. Esta especificación describe un conjunto de instrucciones vectoriales caracterizadas por un propósito genérico, un diseño escalable, la vectorización flexible, soporte para datos mixtos y anchos múltiples e integración con otras extensiones. Los principales tipos de instrucciones a los que se dan soporte son instrucciones de configuración, instrucciones de manejo de memoria, instrucciones aritmético-lógicas, instrucciones de máscara y permutaciones.  

