>>> creator structure -  {
  load_architecture: [Function: load_architecture],
  load_library: [Function: load_library],
  assembly_compile: [Function: assembly_compile],
  execute_program: [Function: execute_program],
  get_state: [Function: get_state],
  compare_states: [Function: compare_states],
  help_instructions: [Function: help_instructions],
  help_pseudoins: [Function: help_pseudoins]
}

CREATOR
-------
version: 4.0
website: https://creatorsim.github.io/

[testing.s] 
>>> Architecture {
  arch_conf: [
    { name: 'Name', value: 'RISC-V (RV32IMFD) V Extenssion' },
    { name: 'Bits', value: '32' },
    {
      name: 'Description',
      value: 'RISC-V is an instruction set architecture (ISA) based on the RISC type and its hardware is free. This architecture was created in 2010 at the University of California, Berkeley.'
    },
    { name: 'Data Format', value: 'big_endian' },
    { name: 'Memory Alignment', value: '1' },
    { name: 'Main Function', value: 'main' },
    { name: 'Passing Convention', value: '1' },
    { name: 'Sensitive Register Name', value: '1' }
  ],
  components: [
    {
      name: 'Control registers',
      type: 'ctrl_registers',
      double_precision: false,
      elements: [Array]
    },
    {
      name: 'VEC registers',
      type: 'vec_registers',
      double_precission: false,
      elements: [Array]
    },
    {
      name: 'Integer registers',
      type: 'int_registers',
      double_precision: false,
      elements: [Array]
    },
    {
      name: 'Floating point registers',
      type: 'fp_registers',
      double_precision: true,
      double_precision_type: 'extended',
      elements: [Array]
    }
  ],
  instructions: [
    {
      name: 'vload',
      type: 'Vector arithmetic',
      signature_definition: 'F0 F1 F2',
      signature: 'vload,VEC-Reg,inm-signed',
      signatureRaw: 'vload rd inm',
      co: '0110011',
      cop: '0000000000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = inm',
      separated: [Array],
      help: ''
    },
    {
      name: 'add',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F3 F2 F1',
      signature: 'add,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'add rd rs1 rs2',
      co: '0110011',
      cop: '0000000000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs2 + rs1',
      separated: [Array],
      help: ''
    },
    {
      name: 'addi',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F3 F2 F1',
      signature: 'addi,INT-Reg,INT-Reg,inm-signed',
      signatureRaw: 'addi rd rs1 inm',
      co: '0010011',
      cop: '000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 + inm;',
      separated: [Array],
      help: ''
    },
    {
      name: 'and',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'and,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'and rd rs1 rs2',
      co: '0110011',
      cop: '0000000111',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 & rs2;',
      separated: [Array],
      help: ''
    },
    {
      name: 'andi',
      type: 'Logic',
      signature_definition: 'F0 F3 F2 F1',
      signature: 'andi,INT-Reg,INT-Reg,inm-signed',
      signatureRaw: 'andi rd rs1 inm',
      co: '0010011',
      cop: '111',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 & capi_int2uint(inm);',
      separated: [Array],
      help: ''
    },
    {
      name: 'auipc',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F2 F1',
      signature: 'auipc,INT-Reg,offset_words',
      signatureRaw: 'auipc rd inm',
      co: '0010111',
      cop: '',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = PC + (inm << 12);',
      separated: [Array],
      help: ''
    },
    {
      name: 'beq',
      type: 'Conditional bifurcation',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'beq,INT-Reg,INT-Reg,offset_words',
      signatureRaw: 'beq rs1 rs2 inm',
      co: '1100011',
      cop: '000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'if (rs1 === rs2)\n PC = PC + ((inm << 16) >> 14); ',
      separated: [Array],
      help: ''
    },
    {
      name: 'bge',
      type: 'Conditional bifurcation',
      signature_definition: 'F0 F3 F2 F1',
      signature: 'bge,INT-Reg,INT-Reg,offset_words',
      signatureRaw: 'bge rs1 rs2 inm',
      co: '1100011',
      cop: '101',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'if (capi_uint2int(rs1) >= capi_uint2int(rs2))\n' +
        ' PC = PC + ((inm << 16) >> 14);',
      separated: [Array],
      help: ''
    },
    {
      name: 'bgeu',
      type: 'Conditional bifurcation',
      signature_definition: 'F0 F3 F2 F1',
      signature: 'bgeu,INT-Reg,INT-Reg,offset_words',
      signatureRaw: 'bgeu rs1 rs2 inm',
      co: '1100011',
      cop: '111',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'if (capi_int2uint(rs1) > capi_int2uint(rs2))\n' +
        ' PC = PC + ((inm << 16) >> 14);',
      separated: [Array],
      help: ''
    },
    {
      name: 'blt',
      type: 'Conditional bifurcation',
      signature_definition: 'F0 F3 F2 F1',
      signature: 'blt,INT-Reg,INT-Reg,offset_words',
      signatureRaw: 'blt rs1 rs2 inm',
      co: '1100011',
      cop: '100',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'if (capi_uint2int(rs1) < capi_uint2int(rs2))\n' +
        ' PC = PC + ((inm << 16) >> 14);',
      separated: [Array],
      help: ''
    },
    {
      name: 'bltu',
      type: 'Conditional bifurcation',
      signature_definition: 'F0 F3 F2 F1',
      signature: 'bltu,INT-Reg,INT-Reg,offset_words',
      signatureRaw: 'bltu rs1 rs2 inm',
      co: '1100011',
      cop: '110',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'if (capi_int2uint(rs1) < capi_int2uint(rs2))\n' +
        ' PC = PC + ((inm << 16) >> 14);',
      separated: [Array],
      help: ''
    },
    {
      name: 'bne',
      type: 'Conditional bifurcation',
      signature_definition: 'F0 F3 F2 F1',
      signature: 'bne,INT-Reg,INT-Reg,offset_words',
      signatureRaw: 'bne rs1 rs2 inm',
      co: '1100011',
      cop: '001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'if (rs1 !== rs2)\n PC = PC + ((inm << 16) >> 14);',
      separated: [Array],
      help: ''
    },
    {
      name: 'div',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'div,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'div rd rs1 rs2',
      co: '0110011',
      cop: '0000001100',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'if (rs2 != 0)\n' +
        ' { rd = (rs1 >> 0) / (rs2 >> 0); }\n' +
        " else { capi_raise('Division by zero not allowed'); }",
      separated: [Array],
      help: ''
    },
    {
      name: 'ecall',
      type: 'Syscall',
      co: '000000',
      cop: '001100',
      nwords: 1,
      clk_cycles: 1,
      signature_definition: 'F0',
      signature: 'ecall',
      signatureRaw: 'ecall',
      fields: [Array],
      definition: 'switch(a7){\n' +
        'case 1:\n' +
        "capi_print_int('a0');\n" +
        'break;\n' +
        'case 2:\n' +
        "capi_print_float('fa0');\n" +
        'break;\n' +
        'case 3:\n' +
        "capi_print_double('fa0');\n" +
        'break;\n' +
        'case 4:\n' +
        "capi_print_string('a0');\n" +
        'break;\n' +
        'case 5:\n' +
        "capi_read_int('a0');\n" +
        'break;\n' +
        'case 6:\n' +
        "capi_read_float('fa0');\n" +
        'break;\n' +
        'case 7:\n' +
        "capi_read_double('fa0');\n" +
        'break;\n' +
        'case 8:\n' +
        "capi_read_string('a0', 'a1');\n" +
        'break;\n' +
        'case 9:\n' +
        "capi_sbrk('a0', 'a0');\n" +
        'break;\n' +
        'case 10:\n' +
        'capi_exit();\n' +
        'break;\n' +
        'case 11:\n' +
        "capi_print_char('a0');\n" +
        'break;\n' +
        'case 12:\n' +
        "capi_read_char('a0');\n" +
        'break;\n' +
        '}',
      help: ''
    },
    {
      name: 'fadd.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'FADD.D,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'FADD.D rd rs1 rs2',
      co: '1010011',
      cop: '0000001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 + rs2;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fadd.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'fadd.s,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fadd.s rd rs1 rs2',
      co: '1010011',
      cop: '0000000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs2 + rs1;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fclass.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'fclass.d,INT-Reg,DFP-Reg,cop',
      signatureRaw: 'fclass.d rd rs1 cop2',
      co: '1010011',
      cop: '111000100000001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'let a = capi_float2bin(rs1);\n' +
        'rd=capi_check_ieee(parseInt(a[0]), parseInt(a.slice(1,12), 2), parseInt(a.slice(13), 2));',
      separated: [Array],
      help: ''
    },
    {
      name: 'fclass.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3 F4',
      signature: 'fclass.s,INT-Reg,SFP-Reg,INT-Reg',
      signatureRaw: 'fclass.s rd rs1 rd',
      co: '1010011',
      cop: '111000000000001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'let a = capi_float2bin(rs1);\n' +
        'rd=capi_check_ieee(parseInt(a[0]), parseInt(a.slice(1,9), 2), parseInt(a.slice(10), 2));',
      separated: [Array],
      help: ''
    },
    {
      name: 'fcvt.d.s',
      type: 'Transfer between registers',
      signature_definition: 'F0 F4 F3',
      signature: 'fcvt.d.s,DFP-Reg,SFP-Reg',
      signatureRaw: 'fcvt.d.s rd rs1',
      co: '1010011',
      cop: '010000100000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fcvt.d.w',
      type: 'Transfer between registers',
      signature_definition: 'F0 F4 F3',
      signature: 'fcvt.d.w,DFP-Reg,INT-Reg',
      signatureRaw: 'fcvt.d.w rd rs1',
      co: '1010011',
      cop: '110100100000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = capi_uint2int(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fcvt.d.wu',
      type: 'Transfer between registers',
      signature_definition: 'F0 F4 F3',
      signature: 'fcvt.d.wu,DFP-Reg,INT-Reg',
      signatureRaw: 'fcvt.d.wu rd rs1',
      co: '1010011',
      cop: '110100100001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = capi_int2uint(parseFloat(rs1));',
      separated: [Array],
      help: ''
    },
    {
      name: 'fcvt.s.d',
      type: 'Transfer between registers',
      signature_definition: 'F0 F4 F3',
      signature: 'fcvt.s.d,SFP-Reg,DFP-Reg',
      signatureRaw: 'fcvt.s.d rd rs1',
      co: '1010011',
      cop: '010000000001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fcvt.s.w',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3',
      signature: 'fcvt.s.w,SFP-Reg,INT-Reg',
      signatureRaw: 'fcvt.s.w rd rs1',
      co: '1010011',
      cop: '110100000000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = capi_uint2int(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fcvt.s.wu',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3',
      signature: 'fcvt.s.wu,SFP-Reg,INT-Reg',
      signatureRaw: 'fcvt.s.wu rd rs1',
      co: '1010011',
      cop: '110100000001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = capi_int2uint(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fcvt.w.d',
      type: 'Transfer between registers',
      signature_definition: 'F0 F4 F3',
      signature: 'fcvt.w.d,INT-Reg,DFP-Reg',
      signatureRaw: 'fcvt.w.d rd rs1',
      co: '1010011',
      cop: '110000100000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = parseInt(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fcvt.w.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3',
      signature: 'fcvt.w.s,INT-Reg,SFP-Reg',
      signatureRaw: 'fcvt.w.s rd rs1',
      co: '1010011',
      cop: '110000000000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = parseInt(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fcvt.wu.d',
      type: 'Transfer between registers',
      signature_definition: 'F0 F4 F3',
      signature: 'fcvt.wu.d,INT-Reg,DFP-Reg',
      signatureRaw: 'fcvt.wu.d rd rs1',
      co: '1010011',
      cop: '110000100001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = capi_int2uint(parseInt(rs1));',
      separated: [Array],
      help: ''
    },
    {
      name: 'fcvt.wu.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3',
      signature: 'fcvt.wu.s,INT-Reg,SFP-Reg',
      signatureRaw: 'fcvt.wu.s rd rs1',
      co: '1010011',
      cop: '110000000001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = capi_int2uint(parseInt(rs1));',
      separated: [Array],
      help: ''
    },
    {
      name: 'fdiv.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'fdiv.d,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'fdiv.d rd rs1 rs2',
      co: '1010011',
      cop: '0001101',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'if (rs2 != 0)\n' +
        ' { rd = rs1 / rs2; }\n' +
        " else { capi_raise('Division by zero not allowed'); }",
      separated: [Array],
      help: ''
    },
    {
      name: 'fdiv.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'fdiv.s,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fdiv.s rd rs1 rs2',
      co: '1010011',
      cop: '0001100',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'if (rs2 != 0)\n' +
        ' { rd = rs1 / rs2; }\n' +
        " else { capi_raise('Division by zero not allowed'); }",
      separated: [Array],
      help: ''
    },
    {
      name: 'feq.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'feq.d,INT-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'feq.d rd rs1 rs2',
      co: '1010011',
      cop: '1010001010',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (rs1 == rs2) ? 1 : 0;',
      separated: [Array],
      help: ''
    },
    {
      name: 'feq.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'feq.s,INT-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'feq.s rd rs1 rs2',
      co: '1010011',
      cop: '1010000010',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (rs1 === rs2) ? 1 : 0;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fld',
      type: 'Memory access',
      signature_definition: 'F0 F4 F1 (F2)',
      signature: 'fld,DFP-Reg,inm-unsigned,(INT-Reg)',
      signatureRaw: 'fld rd inm (rs1)',
      co: '0000111',
      cop: '011',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: " var isnotalign = capi_bad_align(rs1+inm, 'd');\n" +
        " if (isnotalign) { capi_raise('The memory must be align'); }\n" +
        " var val1 = capi_mem_read(rs1+inm, 'w', rd_name);\n" +
        " var val2 = capi_mem_read(rs1+inm+4, 'w', rd_name);\n" +
        ' var buf = new ArrayBuffer(8);\n' +
        ' var arr = (new Uint32Array(buf));\n' +
        ' arr[1] = val1;\n' +
        ' arr[0] = val2;\n' +
        ' rd = (new Float64Array(buf))[0];',
      separated: [Array],
      help: ''
    },
    {
      name: 'fle.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'fle.d,INT-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'fle.d rd rs1 rs2',
      co: '1010011',
      cop: '1010001000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (rs1 <= rs2) ? 1 : 0;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fle.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'fle.s,INT-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fle.s rd rs1 rs2',
      co: '1010011',
      cop: '1010000000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (rs1 <= rs2) ? 1 : 0;',
      separated: [Array],
      help: ''
    },
    {
      name: 'flt.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'flt.d,INT-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'flt.d rd rs1 rs2',
      co: '1010011',
      cop: '1010001001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (rs1 < rs2) ? 1 : 0;',
      separated: [Array],
      help: ''
    },
    {
      name: 'flt.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'flt.s,INT-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'flt.s rd rs1 rs2',
      co: '1010011',
      cop: '1010000001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (rs1 < rs2) ? 1 : 0;',
      separated: [Array],
      help: ''
    },
    {
      name: 'flw',
      type: 'Memory access',
      signature_definition: 'F0 F4 F1 (F2)',
      signature: 'flw,SFP-Reg,inm-unsigned,(INT-Reg)',
      signatureRaw: 'flw rd inm (rs2)',
      co: '0000111',
      cop: '010',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: "rd = capi_mem_read(rs2+inm, 'w', rd_name);\n" +
        ' rd = capi_uint2float32(rd);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fmadd.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F4 F3 F1',
      signature: 'FMADD.D,DFP-Reg,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'FMADD.D rd rs1 rs2 rs3',
      co: '1000011',
      cop: '01',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 * rs2 + rs3;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fmadd.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F4 F3 F1',
      signature: 'fmadd.s,SFP-Reg,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fmadd.s rd rs1 rs2 rs3',
      co: '1000011',
      cop: '00',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 * rs2 + rs3;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fmax.d',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'FMAX.D,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'FMAX.D rd rs1 rs2',
      co: '1010011',
      cop: '0010101001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = Math.max(rs1, rs2);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fmax.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'fmax.s,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fmax.s rd rs1 rs2',
      co: '1010011',
      cop: '0010100001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = Math.max(rs1, rs2);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fmin.d',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'FMIN.D,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'FMIN.D rd rs1 rs2',
      co: '1010011',
      cop: '0010101000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = Math.min(rs1, rs2);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fmin.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'fmin.s,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fmin.s rd rs1 rs2',
      co: '1010011',
      cop: '0010100000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = Math.min(rs1, rs2);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fmsub.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F4 F3 F1',
      signature: 'fmsub.d,DFP-Reg,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'fmsub.d rd rs1 rs2 rs3',
      co: '1000111',
      cop: '01',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 * rs2 - rs3;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fmsub.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F4 F3 F1',
      signature: 'fmsub.s,SFP-Reg,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fmsub.s rd rs1 rs2 rs3',
      co: '1000111',
      cop: '00',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 * rs2 - rs3;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fmul.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'fmul.d,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'fmul.d rd rs1 rs2',
      co: '1010011',
      cop: '0001001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 * rs2;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fmul.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'fmul.s,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fmul.s rd rs1 rs2',
      co: '1010011',
      cop: '0001000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs2 * rs1;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fmv.w.x',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3',
      signature: 'fmv.w.x,SFP-Reg,INT-Reg',
      signatureRaw: 'fmv.w.x rd rs1',
      co: '1010011',
      cop: '111100000000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = capi_uint2float32(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fmv.x.w',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3',
      signature: 'fmv.x.w,INT-Reg,SFP-Reg',
      signatureRaw: 'fmv.x.w rd rs1',
      co: '1010011',
      cop: '111000000000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = capi_float322uint(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fnmadd.d',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F5 F4 F3 F1',
      signature: 'fnmadd.d,DFP-Reg,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'fnmadd.d rd rs1 rs2 rs3',
      co: '1001111',
      cop: '01',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = -rs1 * rs2 - rs3;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fnmadd.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F4 F3 F1',
      signature: 'fnmadd.s,SFP-Reg,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fnmadd.s rd rs1 rs2 rs3',
      co: '1001111',
      cop: '00',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = -rs1 * rs2 - rs3;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fnmsub.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F4 F3 F1',
      signature: 'fnmsub.d,DFP-Reg,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'fnmsub.d rd rs1 rs2 rs3',
      co: '1001011',
      cop: '01',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = -rs1 * rs2 + rs3;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fnmsub.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F4 F3 F1',
      signature: 'fnmsub.s,SFP-Reg,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fnmsub.s rd rs1 rs2 rs3',
      co: '1001011',
      cop: '00',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = -rs1 * rs2 + rs3;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fsd',
      type: 'Memory access',
      signature_definition: 'F0 F2 F3 (F1)',
      signature: 'fsd,DFP-Reg,inm-unsigned,(INT-Reg)',
      signatureRaw: 'fsd ft off (base)',
      co: '0100111',
      cop: '011',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'var val = capi_split_double(ft, 0);\n' +
        " capi_mem_write(base+off, val, 'w', ft_name);\n" +
        ' val = capi_split_double(ft, 1);\n' +
        " capi_mem_write(base+off+4, val, 'w', ft_name);",
      separated: [Array],
      help: ''
    },
    {
      name: 'fsgnj.d',
      type: 'Transfer between registers',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'fsgnj.d,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'fsgnj.d rd rs1 rs2',
      co: '1010011',
      cop: '0010001000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (rs2 > 0) ? Math.abs(rs1) : -Math.abs(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fsgnj.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'fsgnj.s,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fsgnj.s rd rs1 rs2',
      co: '1010011',
      cop: '0010000000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (rs2 >= 0) ? Math.abs(rs1) : -Math.abs(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fsgnjn.d',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'fsgnjn.d,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'fsgnjn.d rd rs1 rs2',
      co: '1010011',
      cop: '0010001001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (rs2 > 0) ? -Math.abs(rs1) : +Math.abs(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fsgnjn.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'fsgnjn.s,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fsgnjn.s rd rs1 rs2',
      co: '1010011',
      cop: '0010000001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (rs2 <= 0) ? Math.abs(rs1) : -Math.abs(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fsgnjx.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'fsgnjx.d,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'fsgnjx.d rd rs1 rs2',
      co: '1010011',
      cop: '0010001010',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'let a = rs1<0; let b = rs2<0;\n' +
        'rd = (a^b) ? -Math.abs(rs1) : Math.abs(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fsgnjx.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'fsgnjx.s,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fsgnjx.s rd rs1 rs2',
      co: '1010011',
      cop: '0010000010',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'let a = rs1<0; let b = rs2<0;\n' +
        'rd = (a^b) ? -Math.abs(rs1) : Math.abs(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fsqrt.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3',
      signature: 'FSQRT.D,DFP-Reg,DFP-Reg',
      signatureRaw: 'FSQRT.D rd rs1',
      co: '1010011',
      cop: '010110100000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = Math.sqrt(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fsqrt.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3',
      signature: 'fsqrt.s,SFP-Reg,SFP-Reg',
      signatureRaw: 'fsqrt.s rd rs1',
      co: '1010011',
      cop: '010110000000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = Math.sqrt(rs1);',
      separated: [Array],
      help: ''
    },
    {
      name: 'fsub.d',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'FSUB.D,DFP-Reg,DFP-Reg,DFP-Reg',
      signatureRaw: 'FSUB.D rd rs1 rs2',
      co: '1010011',
      cop: '0000101',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 - rs2;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fsub.s',
      type: 'Arithmetic floating point',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'fsub.s,SFP-Reg,SFP-Reg,SFP-Reg',
      signatureRaw: 'fsub.s rd rs1 rs2',
      co: '1010011',
      cop: '0001100',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 - rs2;',
      separated: [Array],
      help: ''
    },
    {
      name: 'fsw',
      type: 'Memory access',
      signature_definition: 'F0 F3 F1 (F2)',
      signature: 'fsw,SFP-Reg,inm-unsigned,(INT-Reg)',
      signatureRaw: 'fsw rs1 inm (rs2)',
      co: '0100111',
      cop: '010',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'var val1 = capi_float322uint(rs1);\n' +
        " capi_mem_write(rs2+inm, val1, 'w', rs1_name);",
      separated: [Array],
      help: ''
    },
    {
      name: 'jal',
      type: 'Unconditional bifurcation',
      signature_definition: 'F0 F2 F1',
      signature: 'jal,INT-Reg,inm-unsigned',
      signatureRaw: 'jal rd inm',
      co: '1101111',
      cop: '',
      help: '',
      properties: [Array],
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = PC;\n' +
        ' PC = inm;\n' +
        ' capi_callconv_begin(inm); capi_drawstack_begin(inm);',
      separated: [Array]
    },
    {
      name: 'jalr',
      type: 'Unconditional bifurcation',
      signature_definition: 'F0 F3 F1 (F2)',
      signature: 'jalr,INT-Reg,inm-signed,(INT-Reg)',
      signatureRaw: 'jalr rd inm (rs1)',
      co: '1100111',
      cop: '000',
      help: '',
      properties: [Array],
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = PC;\n' +
        ' PC = (rs1+inm)&~1;\n' +
        ' capi_callconv_end(); capi_drawstack_end(PC);',
      separated: [Array]
    },
    {
      name: 'lb',
      type: 'Memory access',
      signature_definition: 'F0 F3 F1 (F2)',
      signature: 'lb,INT-Reg,inm-unsigned,(INT-Reg)',
      signatureRaw: 'lb rd inm (rs1)',
      co: '0000011',
      cop: '000',
      nwords: '1',
      fields: [Array],
      definition: "rd = capi_mem_read(inm+rs1, 'b', rd_name);",
      separated: [Array],
      help: ''
    },
    {
      name: 'lbu',
      type: 'Memory access',
      signature_definition: 'F0 F3 F1 (F2)',
      signature: 'lbu,INT-Reg,inm-unsigned,(INT-Reg)',
      signatureRaw: 'lbu rd inm (rs1)',
      co: '0000011',
      cop: '100',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'var addr = capi_int2uint(rs1)+inm;\n' +
        " rd = capi_mem_read(addr, 'bu', rd_name);\n" +
        ' rd = capi_int2uint(rd);',
      separated: [Array],
      help: ''
    },
    {
      name: 'lh',
      type: 'Memory access',
      signature_definition: 'F0 F3 F1 (F2)',
      signature: 'lh,INT-Reg,inm-unsigned,(INT-Reg)',
      signatureRaw: 'lh rd inm (rs1)',
      co: '0000011',
      cop: '001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: "rd = capi_mem_read(inm+rs1, 'h', rd_name);",
      separated: [Array],
      help: ''
    },
    {
      name: 'lhu',
      type: 'Memory access',
      signature_definition: 'F0 F3 F1 (F2)',
      signature: 'lhu,INT-Reg,inm-unsigned,(INT-Reg)',
      signatureRaw: 'lhu rd inm (rs1)',
      co: '0000011',
      cop: '101',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'var addr = capi_int2uint(rs1)+inm;\n' +
        " rd = capi_mem_read(addr, 'hu', rd_name);\n" +
        ' rd = capi_int2uint(rd);',
      separated: [Array],
      help: ''
    },
    {
      name: 'lui',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F2 F1',
      signature: 'lui,INT-Reg,inm-signed',
      signatureRaw: 'lui rd inm',
      co: '0110111',
      cop: '',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = inm << 12;',
      separated: [Array],
      help: ''
    },
    {
      name: 'lw',
      type: 'Memory access',
      signature_definition: 'F0 F3 F1 (F2)',
      signature: 'lw,INT-Reg,inm-unsigned,(INT-Reg)',
      signatureRaw: 'lw rd inm (rs1)',
      co: '0000011',
      cop: '010',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'var addr = capi_int2uint(rs1)+inm;\n' +
        " rd = capi_mem_read(addr, 'w', rd_name);",
      separated: [Array],
      help: ''
    },
    {
      name: 'mul',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'mul,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'mul rd rs1 rs2',
      co: '0110011',
      cop: '0000001000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = capi_uint2int(rs1) * capi_uint2int(rs2);',
      separated: [Array],
      help: ''
    },
    {
      name: 'mulh',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'mulh,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'mulh rd rs1 rs2',
      co: '0110011',
      cop: '0000001010',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = ((rs1 * rs2) >>> 32);',
      separated: [Array],
      help: ''
    },
    {
      name: 'mulhsu',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'mulhsu,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'mulhsu rd rs1 rs2',
      co: '0110011',
      cop: '0000001000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = ((rs1 * capi_int2uint(rs2)) >>> 32);',
      separated: [Array],
      help: ''
    },
    {
      name: 'mulhu',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'mulhu,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'mulhu rd rs1 rs2',
      co: '0110011',
      cop: '0000001011',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = ((capi_int2uint(rs1) * capi_int2uint(rs2)) >>> 32);',
      separated: [Array],
      help: ''
    },
    {
      name: 'or',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'or,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'or rd rs1 rs2',
      co: '0110011',
      cop: '0000000110',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 | rs2;',
      separated: [Array],
      help: ''
    },
    {
      name: 'ori',
      type: 'Logic',
      signature_definition: 'F0 F3 F2 F1',
      signature: 'ori,INT-Reg,INT-Reg,inm-signed',
      signatureRaw: 'ori rd rs1 inm',
      co: '0010011',
      cop: '110',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 | inm;',
      separated: [Array],
      help: ''
    },
    {
      name: 'rdcycle',
      type: 'Syscall',
      co: '1110011',
      cop: '010',
      nwords: 1,
      clk_cycles: 1,
      signature_definition: 'F0 F1',
      signature: 'rdcycle,INT-Reg',
      signatureRaw: 'rdcycle rd',
      fields: [Array],
      definition: 'rd = capi_get_clk_cycles();',
      help: ''
    },
    {
      name: 'rem',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F5 F3 F2',
      signature: 'rem,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'rem rd rs1 rs2',
      co: '0110011',
      cop: '0000001110',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 % rs2;',
      separated: [Array],
      help: ''
    },
    {
      name: 'sb',
      type: 'Memory access',
      signature_definition: 'F0 F2 F1 (F3)',
      signature: 'sb,INT-Reg,inm-unsigned,(INT-Reg)',
      signatureRaw: 'sb rs2 inm (rs1)',
      co: '0100011',
      cop: '000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: "capi_mem_write(rs1+inm, rs2, 'b', rs2_name);",
      separated: [Array],
      help: ''
    },
    {
      name: 'sh',
      type: 'Memory access',
      signature_definition: 'F0 F2 F1 (F3)',
      signature: 'sh,INT-Reg,inm-unsigned,(INT-Reg)',
      signatureRaw: 'sh rs2 inm (rs1)',
      co: '0100011',
      cop: '001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: "capi_mem_write(inm+rs1, rs2, 'h', rs2_name);",
      separated: [Array],
      help: ''
    },
    {
      name: 'sll',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'sll,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'sll rd rs1 rs2',
      co: '0110011',
      cop: '0000000001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = capi_int2uint(rs1 << rs2);',
      separated: [Array],
      help: ''
    },
    {
      name: 'slli',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F1 F3 F4',
      signature: 'slli,INT-Reg,INT-Reg,inm-unsigned',
      signatureRaw: 'slli rd rs1 shamt',
      co: '0010011',
      cop: '000000001',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'if (shamt > 0) {rd = capi_int2uint(rs1 << shamt);}',
      separated: [Array],
      help: ''
    },
    {
      name: 'slt',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'slt,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'slt rd rs1 rs2',
      co: '0110011',
      cop: '0000000010',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (capi_uint2int(rs1) < capi_uint2int(rs2)) ? 1 : 0;',
      separated: [Array],
      help: ''
    },
    {
      name: 'slti',
      type: 'Logic',
      signature_definition: 'F0 F3 F2 F1',
      signature: 'slti,INT-Reg,INT-Reg,inm-signed',
      signatureRaw: 'slti rd rs1 inm',
      co: '0010011',
      cop: '010',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (capi_uint2int(rs1) < capi_uint2int(inm)) ? 1 : 0;',
      separated: [Array],
      help: ''
    },
    {
      name: 'sltiu',
      type: 'Logic',
      signature_definition: 'F0 F3 F2 F1',
      signature: 'sltiu,INT-Reg,INT-Reg,inm-signed',
      signatureRaw: 'sltiu rd rs1 inm',
      co: '0010011',
      cop: '011',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (capi_int2uint(rs1) < capi_int2uint(inm)) ? 1 : 0;',
      separated: [Array],
      help: ''
    },
    {
      name: 'sltu',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'sltu,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'sltu rd rs1 rs2',
      co: '0110011',
      cop: '0000000011',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = ((rs1 >>> 0) < (rs2 >>> 0)) ? 1 : 0;',
      separated: [Array],
      help: ''
    },
    {
      name: 'sra',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'sra,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'sra rd rs1 rs2',
      co: '0110011',
      cop: '0100000101',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = capi_int2uint(rs1 >> rs2);',
      separated: [Array],
      help: ''
    },
    {
      name: 'srai',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F1 F3 F4',
      signature: 'srai,INT-Reg,INT-Reg,inm-signed',
      signatureRaw: 'srai rd rs1 shamt',
      co: '0010011',
      cop: '010000101',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'if (shamt > 0) {rd = capi_int2uint(rs1 >> shamt);}',
      separated: [Array],
      help: ''
    },
    {
      name: 'srl',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'srl,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'srl rd rs1 rs2',
      co: '0110011',
      cop: '0000000101',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 >> rs2;',
      separated: [Array],
      help: ''
    },
    {
      name: 'srli',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F1 F3 F4',
      signature: 'srli,INT-Reg,INT-Reg,inm-unsigned',
      signatureRaw: 'srli rd rs1 shamt',
      co: '0010011',
      cop: '000000101',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'if (shamt > 0) {rd = (rs1 >> shamt);}',
      separated: [Array],
      help: ''
    },
    {
      name: 'sub',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'sub,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'sub rd rs1 rs2',
      co: '0110011',
      cop: '0100000000',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 - rs2;',
      separated: [Array],
      help: ''
    },
    {
      name: 'sw',
      type: 'Memory access',
      signature_definition: 'F0 F2 F1 (F3)',
      signature: 'sw,INT-Reg,inm-unsigned,(INT-Reg)',
      signatureRaw: 'sw rs2 inm (rs1)',
      co: '0100011',
      cop: '010',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: "capi_mem_write(inm+rs1, rs2, 'w', rs2_name);",
      separated: [Array],
      help: ''
    },
    {
      name: 'xor',
      type: 'Arithmetic integer',
      signature_definition: 'F0 F4 F3 F2',
      signature: 'xor,INT-Reg,INT-Reg,INT-Reg',
      signatureRaw: 'xor rd rs1 rs2',
      co: '0110011',
      cop: '0000000100',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = (rs1 ^ rs2);',
      separated: [Array],
      help: ''
    },
    {
      name: 'xori',
      type: 'Logic',
      signature_definition: 'F0 F3 F2 F1',
      signature: 'xori,INT-Reg,INT-Reg,inm-signed',
      signatureRaw: 'xori rd rs1 inm',
      co: '0010011',
      cop: '100',
      nwords: 1,
      clk_cycles: 1,
      fields: [Array],
      definition: 'rd = rs1 ^ inm;',
      separated: [Array],
      help: ''
    }
  ],
  pseudoinstructions: [
    {
      name: 'beqz',
      signature_definition: 'beqz F0 F1',
      signature: 'beqz,INT-Reg,offset_words',
      signatureRaw: 'beqz reg1 off',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'beq reg1 x0 off;'
    },
    {
      name: 'bgez',
      signature_definition: 'bgez F0 F1',
      signature: 'bgez,INT-Reg,offset_words',
      signatureRaw: 'bgez reg1 off',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'bge reg1 x0 off;'
    },
    {
      name: 'bgt',
      signature_definition: 'bgt F0 F1 F2',
      signature: 'bgt,INT-Reg,INT-Reg,offset_words',
      signatureRaw: 'bgt reg1 reg2 off',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'blt reg2 reg1 off;'
    },
    {
      name: 'bgtu',
      signature_definition: 'bgtu F0 F1 F2',
      signature: 'bgtu,INT-Reg,INT-Reg,offset_words',
      signatureRaw: 'bgtu reg1 reg2 off',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'bltu reg2 reg1 off;'
    },
    {
      name: 'bgtz',
      signature_definition: 'bgtz F0 F1',
      signature: 'bgtz,INT-Reg,offset_words',
      signatureRaw: 'bgtz reg1 off',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'blt x0 reg1 off;'
    },
    {
      name: 'ble',
      signature_definition: 'ble F0 F1 F2',
      signature: 'ble,INT-Reg,INT-Reg,offset_words',
      signatureRaw: 'ble reg1 reg2 off',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'bge reg2 reg1 off;'
    },
    {
      name: 'bleu',
      signature_definition: 'bleu F0 F1 F2',
      signature: 'bleu,INT-Reg,INT-Reg,offset_words',
      signatureRaw: 'bleu reg1 reg2 off',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'bgeu reg2 reg1 off;'
    },
    {
      name: 'blez',
      signature_definition: 'blez F0 F1',
      signature: 'blez,INT-Reg,offset_words',
      signatureRaw: 'blez reg1 off',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'bge x0 reg1 off;'
    },
    {
      name: 'bltz',
      signature_definition: 'bltz F0 F1',
      signature: 'bltz,INT-Reg,offset_words',
      signatureRaw: 'bltz reg1 off',
      help: 'Conditional branch if Rsrc1 is less than zero.',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'blt reg1 x0 off;'
    },
    {
      name: 'bnez',
      signature_definition: 'bnez F0 F1',
      signature: 'bnez,INT-Reg,offset_words',
      signatureRaw: 'bnez reg1 off',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'bne reg1 x0 off;'
    },
    {
      name: 'fabs.d',
      signature_definition: 'fabs.d F0 F1',
      signature: 'fabs.d,DFP-Reg,DFP-Reg',
      signatureRaw: 'fabs.d reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'fsgnjx.d reg1 reg2 reg2;'
    },
    {
      name: 'fabs.s',
      signature_definition: 'fabs.s F0 F1',
      signature: 'fabs.s,SFP-Reg,SFP-Reg',
      signatureRaw: 'fabs.s reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'fsgnjx.s reg1 reg2 reg2;'
    },
    {
      name: 'fmv.d',
      signature_definition: 'fmv.d F0 F1',
      signature: 'fmv.d,DFP-Reg,DFP-Reg',
      signatureRaw: 'fmv.d reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'fsgnj.d reg1 reg2 reg2;'
    },
    {
      name: 'fmv.s',
      signature_definition: 'fmv.s F0 F1',
      signature: 'fmv.s,SFP-Reg,SFP-Reg',
      signatureRaw: 'fmv.s reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'fsgnj.s reg1 reg2 reg2;'
    },
    {
      name: 'fneg.d',
      signature_definition: 'fneg.d F0 F1',
      signature: 'fneg.d,DFP-Reg,DFP-Reg',
      signatureRaw: 'fneg.d reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'fsgnjn.d reg1 reg2 reg2;'
    },
    {
      name: 'fneg.s',
      signature_definition: 'fneg.s F0 F1',
      signature: 'fneg.s,SFP-Reg,SFP-Reg',
      signatureRaw: 'fneg.s reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'fsgnjn.s reg1 reg2 reg2;'
    },
    {
      name: 'j',
      signature_definition: 'j F0',
      signature: 'j,offset_words',
      signatureRaw: 'j off',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'beq zero zero off;'
    },
    {
      name: 'jalr',
      signature_definition: 'jalr F0',
      signature: 'jalr,INT-Reg',
      signatureRaw: 'jalr rs',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'jalr x1 0 (rs);'
    },
    {
      name: 'jr',
      signature_definition: 'jr F0',
      signature: 'jr,INT-Reg',
      signatureRaw: 'jr rs',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'jalr x0 0 (rs);'
    },
    {
      name: 'la',
      signature_definition: 'la F0 F1',
      signature: 'la,INT-Reg,inm-unsigned',
      signatureRaw: 'la rd addr',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'no_ret_op{tmp=Field.2.(31,0).int - reg.pc;\n' +
        "tmp_hi='0x'+(((tmp&0xFFFFF000)>>12) + ((tmp&0x00000400)>>11)).toString(16);\n" +
        "tmp_low='0x'+(tmp&0x00000FFF).toString(16)};\n" +
        'auipc rd op{tmp_hi};\n' +
        'addi rd rd op{tmp_low};'
    },
    {
      name: 'li',
      signature_definition: 'li F0 F1',
      signature: 'li,INT-Reg,inm-signed',
      signatureRaw: 'li rd val',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'if(Field.2.SIZE<=12){addi rd x0 val;}\n' +
        'else{lui rd 0;\n' +
        'lui rd Field.2.(31,12).int;\n' +
        "addi rd rd op{'0x'+(Field.2.(11,0).int ).toString(16)};}"
    },
    {
      name: 'mv',
      signature_definition: 'mv F0 F1',
      signature: 'mv,INT-Reg,INT-Reg',
      signatureRaw: 'mv reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'addi reg1 reg2 0;'
    },
    {
      name: 'neg',
      signature_definition: 'neg F0 F1',
      signature: 'neg,INT-Reg,INT-Reg',
      signatureRaw: 'neg reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'sub reg1 x0 reg2;'
    },
    {
      name: 'nop',
      signature_definition: 'nop',
      signature: 'nop',
      signatureRaw: 'nop',
      help: '',
      properties: [],
      nwords: 1,
      fields: [],
      definition: 'addi x0 x0 0;'
    },
    {
      name: 'not',
      signature_definition: 'not F0 F1',
      signature: 'not,INT-Reg,INT-Reg',
      signatureRaw: 'not reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'xori reg1 reg2 -1;'
    },
    {
      name: 'ret',
      signature_definition: 'ret',
      signature: 'ret',
      signatureRaw: 'ret',
      help: '',
      properties: [],
      nwords: 1,
      fields: [],
      definition: 'jalr x0 0 (x1);'
    },
    {
      name: 'seqz',
      signature_definition: 'seqz F0 F1',
      signature: 'seqz,INT-Reg,INT-Reg',
      signatureRaw: 'seqz reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'sltiu reg1 reg2 1;'
    },
    {
      name: 'sgtz',
      signature_definition: 'sgtz F0 F1',
      signature: 'sgtz,INT-Reg,INT-Reg',
      signatureRaw: 'sgtz reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'slt reg1 x0 reg2;'
    },
    {
      name: 'sltz',
      signature_definition: 'sltz F0 F1',
      signature: 'sltz,INT-Reg,INT-Reg',
      signatureRaw: 'sltz reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'slt reg1 reg2 x0;'
    },
    {
      name: 'snez',
      signature_definition: 'snez F0 F1',
      signature: 'snez,INT-Reg,INT-Reg',
      signatureRaw: 'snez reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'sltu reg1 x0 reg2;'
    },
    {
      name: 'zext.b',
      signature_definition: 'zext.b F0 F1',
      signature: 'zext.b,INT-Reg,INT-Reg',
      signatureRaw: 'zext.b reg1 reg2',
      help: '',
      properties: [],
      nwords: 1,
      fields: [Array],
      definition: 'andi reg1 reg2 255;'
    }
  ],
  directives: [
    { name: '.data', action: 'data_segment', size: null },
    { name: '.text', action: 'code_segment', size: null },
    { name: '.bss', action: 'global_symbol', size: null },
    { name: '.zero', action: 'space', size: '1' },
    { name: '.align', action: 'align', size: null },
    { name: '.balign', action: 'balign', size: null },
    { name: '.globl', action: 'global_symbol', size: null },
    { name: '.string', action: 'ascii_null_end', size: null },
    { name: '.byte', action: 'byte', size: '1' },
    { name: '.half', action: 'half_word', size: '2' },
    { name: '.word', action: 'word', size: '4' },
    { name: '.dword', action: 'double_word', size: '8' },
    { name: '.float', action: 'float', size: '4' },
    { name: '.double', action: 'double', size: '8' }
  ],
  memory_layout: [
    { name: 'text start', value: '0x00000000' },
    { name: 'text end', value: '0x001FFFFF' },
    { name: 'data start', value: '0x00200000' },
    { name: 'data end', value: '0x05BBFCBF' },
    { name: 'stack start', value: '0x0FFFFFFC' },
    { name: 'stack end', value: '0x0FFFFFFF' }
  ]
}
inicio compilador
>>> Starting execution
>>> execute program check
>>> Execute program one shot -  begin check
>>> executing instruction
>>> executing instruction - check 1
>>> instructions lenght : 1
>>> write register end
>>> heyyy
 >>> eval 
/* Read all instruction fields */
var rd      = readRegister (1 ,0, "VEC-Reg");
var inm = -1;
var rd_prev = readRegister (1 ,0, "VEC-Reg");
var rd_name = 'v1';

/* Original instruction definition */
rd = inm

/* Modify values */
writeRegister(rd, 1, 0, "VEC-Reg");

>>> instructions execute index
>>> fin preload
>>> Ending xecution
[Architecture] Architecture 'architecture/RISC_V_RV32IMFD_VExtenssion.json' loaded successfully.
[Library] Without library
[Compile] Code 'testing.s' compiled successfully.
[Execute] Executed successfully.
>>>> get registers
	>>> Control registers
	>>> VEC registers
	>>> Integer registers
	>>> Floating point registers
[FinalState] cr[PC]:0x4; cr[vstart]:0x0; cr[vxsat]:0x0; cr[vxrm]:0x0; cr[vcsr]:0x0; cr[vl]:0x80; cr[vtype]:0x0; cr[vlenb]:0x10; vr[v1]:0xffffffff; vr[v2]:0x0; vr[v3]:0x0; vr[v4]:0x0; ir[x0,zero]:0x0; ir[x1,ra]:0xffffffff; ir[x2,sp]:0xffffffc; ir[x3,gp]:0x0; ir[x4,tp]:0x0; ir[x5,t0]:0x0; ir[x6,t1]:0x0; ir[x7,t2]:0x0; ir[x8,fp,s0]:0x0; ir[x9,s1]:0x0; ir[x10,a0]:0x0; ir[x11,a1]:0x0; ir[x12,a2]:0x0; ir[x13,a3]:0x0; ir[x14,a4]:0x0; ir[x15,a5]:0x0; ir[x16,a6]:0x0; ir[x17,a7]:0x0; ir[x18,s2]:0x0; ir[x19,s3]:0x0; ir[x20,s4]:0x0; ir[x21,s5]:0x0; ir[x22,s6]:0x0; ir[x23,s7]:0x0; ir[x24,s8]:0x0; ir[x25,s9]:0x0; ir[x26,s10]:0x0; ir[x27,s11]:0x0; ir[x28,t3]:0x0; ir[x29,t4]:0x0; ir[x30,t5]:0x0; ir[x31,t6]:0x0; fpr[f0,ft0]:0x0000000000000000; fpr[f1,ft1]:0x0000000000000000; fpr[f2,ft2]:0x0000000000000000; fpr[f3,ft3]:0x0000000000000000; fpr[f4,ft4]:0x0000000000000000; fpr[f5,ft5]:0x0000000000000000; fpr[f6,ft6]:0x0000000000000000; fpr[f7,ft7]:0x0000000000000000; fpr[f8,fs0]:0x0000000000000000; fpr[f9,fs1]:0x0000000000000000; fpr[f10,fa0]:0x0000000000000000; fpr[f11,fa1]:0x0000000000000000; fpr[f12,fa2]:0x0000000000000000; fpr[f13,fa3]:0x0000000000000000; fpr[f14,fa4]:0x0000000000000000; fpr[f15,fa5]:0x0000000000000000; fpr[f16,fa6]:0x0000000000000000; fpr[f17,fa7]:0x0000000000000000; fpr[f18,fs2]:0x0000000000000000; fpr[f19,fs3]:0x0000000000000000; fpr[f20,fs4]:0x0000000000000000; fpr[f21,fs5]:0x0000000000000000; fpr[f22,fs6]:0x0000000000000000; fpr[f23,fs7]:0x0000000000000000; fpr[f24,fs8]:0x0000000000000000; fpr[f25,fs9]:0x0000000000000000; fpr[f26,fs10]:0x0000000000000000; fpr[f27,fs11]:0x0000000000000000; fpr[f28,ft8]:0x0000000000000000; fpr[f29,ft9]:0x0000000000000000; fpr[f30,ft10]:0x0000000000000000; fpr[f31,ft11]:0x0000000000000000; keyboard[0x0]:''; display[0x0]:''; 

