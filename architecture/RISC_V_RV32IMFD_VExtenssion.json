{
  "arch_conf": [
    {
      "name": "Name",
      "value": "RISC-V (RV32IMFD) V Extenssion"
    },
    {
      "name": "Bits",
      "value": "32"
    },
    {
      "name": "Description",
      "value": "RISC-V is an instruction set architecture (ISA) based on the RISC type and its hardware is free. This architecture was created in 2010 at the University of California, Berkeley."
    },
    {
      "name": "Data Format",
      "value": "big_endian"
    },
    {
      "name": "Memory Alignment",
      "value": "1"
    },
    {
      "name": "Main Function",
      "value": "main"
    },
    {
      "name": "Passing Convention",
      "value": "1"
    },
    {
      "name": "Sensitive Register Name",
      "value": "1"
    }
  ],
  "vlen": 128,
  "lmulExp": 0,
  "elen": 64,
  "sew": 64,
  "ma": 0,
  "ta": 1,
  "components": [
    {
      "name": "Control registers",
      "type": "ctrl_registers",
      "double_precision": false,
      "elements": [
        {
          "name": [
            "PC"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "program_counter"
          ]
        }
      ]
    },
    {
      "name": "Vec Control Registers",
      "type": "ctrl_registers",
      "double_precision": false,
      "elements": [
        {
          "name": [
            "vstart"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "vxsat"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "vxrm"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "vcsr"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "vl"
          ],
          "nbits": "32",
          "value": 2,
          "default_value": 2,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "vtype"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "vlenb"
          ],
          "nbits": "32",
          "value": 16,
          "default_value": 16,
          "properties": [
            "read",
            "ignore_write"
          ]
        }
      ]
    },
    {
      "name": "VEC registers",
      "type": "vec_registers",
      "double_precision": false,
      "elements": [
        {
          "name": [
            "v0"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v1"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v2"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v3"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v4"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v5"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v6"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v7"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v8"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v9"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v10"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v11"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v12"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v13"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v14"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v15"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v16"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v17"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v18"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v19"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v20"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v21"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v22"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v23"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v24"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v25"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v26"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v27"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v28"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v29"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v30"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        },
        {
          "name": [
            "v31"
          ],
          "nbits": 128,
          "value": 0,
          "default_value": 0,
          "properties": [
            "write",
            "read"
          ]
        }
      ]
    },
    {
      "name": "Integer registers",
      "type": "int_registers",
      "double_precision": false,
      "elements": [
        {
          "name": [
            "x0",
            "zero"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "ignore_write"
          ]
        },
        {
          "name": [
            "x1",
            "ra"
          ],
          "nbits": "32",
          "value": 4294967295,
          "default_value": 4294967295,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x2",
            "sp"
          ],
          "nbits": "32",
          "value": 268435452,
          "default_value": 268435452,
          "properties": [
            "read",
            "write",
            "stack_pointer"
          ]
        },
        {
          "name": [
            "x3",
            "gp"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "global_pointer"
          ]
        },
        {
          "name": [
            "x4",
            "tp"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x5",
            "t0"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x6",
            "t1"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x7",
            "t2"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x8",
            "fp",
            "s0"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "frame_pointer",
            "saved"
          ]
        },
        {
          "name": [
            "x9",
            "s1"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "x10",
            "a0"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x11",
            "a1"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x12",
            "a2"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x13",
            "a3"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x14",
            "a4"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x15",
            "a5"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x16",
            "a6"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x17",
            "a7"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x18",
            "s2"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "x19",
            "s3"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "x20",
            "s4"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "x21",
            "s5"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "x22",
            "s6"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "x23",
            "s7"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "x24",
            "s8"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "x25",
            "s9"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "x26",
            "s10"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "x27",
            "s11"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "x28",
            "t3"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x29",
            "t4"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x30",
            "t5"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "x31",
            "t6"
          ],
          "nbits": "32",
          "value": 0,
          "default_value": 0,
          "properties": [
            "read",
            "write"
          ]
        }
      ]
    },
    {
      "name": "Floating point registers",
      "type": "fp_registers",
      "double_precision": true,
      "double_precision_type": "extended",
      "elements": [
        {
          "name": [
            "f0",
            "ft0"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f1",
            "ft1"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f2",
            "ft2"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f3",
            "ft3"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f4",
            "ft4"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f5",
            "ft5"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f6",
            "ft6"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f7",
            "ft7"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f8",
            "fs0"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "f9",
            "fs1"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "f10",
            "fa0"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f11",
            "fa1"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f12",
            "fa2"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f13",
            "fa3"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f14",
            "fa4"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f15",
            "fa5"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f16",
            "fa6"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f17",
            "fa7"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f18",
            "fs2"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "f19",
            "fs3"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "f20",
            "fs4"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "f21",
            "fs5"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "f22",
            "fs6"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "f23",
            "fs7"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "f24",
            "fs8"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "f25",
            "fs9"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "f26",
            "fs10"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "f27",
            "fs11"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write",
            "saved"
          ]
        },
        {
          "name": [
            "f28",
            "ft8"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f29",
            "ft9"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f30",
            "ft10"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        },
        {
          "name": [
            "f31",
            "ft11"
          ],
          "nbits": "64",
          "value": 0.0,
          "default_value": 0.0,
          "properties": [
            "read",
            "write"
          ]
        }
      ]
    }
  ],
  "instructions": [
    {
      "name": "vadd.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F3 F2 F1 v0.t",
      "signature": "vadd.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vadd.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vadd.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function add (vd, vs1, vs2) {\nfor(let i = 0; i < checkVl(); ++i) {\nvd[i] = vs2[i] + vs1[i];\n}\n return vd;}\n vd = maskedOperation(checkVl(), vs1, vs2, vd, add);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vadd.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "vadd.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vadd.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vadd.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "for(let i = 0; i < checkVl(); ++i) {\nvd[i] = vs2[i] + vs1[i];\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsub.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F3 F2 F1 v0.t",
      "signature": "vsub.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vsub.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsub.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function vsubvv (vd, vs2, vs1) {\nfor(let i = 0; i < checkVl(); ++i) {\nvd[i] = vs2[i] - vs1[i];\n}\nreturn vd;\n}\nmaskedOperation(checkVl(), vs2, vs1, vd, vsubvv);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsub.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "vsub.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vsub.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsub.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "for(let i = 0; i < checkVl(); ++i) {\nvd[i] = vs2[i] - vs1[i];\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vadd.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F3 F2 F1 v0.t",
      "signature": "vadd.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vadd.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vadd.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function vaddVX(vd, vs2, rs1) {\nfor (let i = 0; i < checkVl(); ++i) {\nvd[i] = vs2[i] + rs1;\n}\return vd;\n}\nvd = maskedOperation(checkVl(), vs2, rs1, vd, vecIntOperationWrapperFactory(vaddVX));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vadd.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "vadd.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vadd.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vadd.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "function vaddVX(vd, vs2, rs1) {\nfor (let i = 0; i < checkVl(); ++i) {\nvd[i] = vs2[i] + rs1;\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, rs1, vaddVX);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsub.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F3 F2 F1 v0.t",
      "signature": "vsub.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vsub.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsub.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "v0.t",
          "type": "INT-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function vsubVX(vd, vs2, rs1) {\n  for(let i = 0; i < checkVl(); ++i) {\n    vd[i] = vs2[i] - rs1;\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, rs1, vd, vecIntOperationWrapperFactory(vsubVX));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsub.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "vsub.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vsub.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsub.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function vsubVX(vd, vs2, rs1) {\n  for(let i = 0; i < checkVl(); ++i) {\n    vd[i] = vs2[i] - rs1;\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, rs1, vsubVX);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vadd.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F3 F2 F1 v0.t",
      "signature": "vadd.vi,VEC-Reg,VEC-Reg,inm-signed,v0.t",
      "signatureRaw": "vadd.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vadd.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "starbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function vaddVI(vd, vs2, inm) {for (let i = 0; i < checkVl(); ++i) {\nvd[i] = vs2[i] + inm;}\nreturn vd;}\nvd = maskedOperation(checkVl(), vs2, inm, vd, vecIntOperationWrapperFactory(vaddVI));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vadd.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "vadd.vi,VEC-Reg,VEC-Reg,inm-signed",
      "signatureRaw": "vadd.vi vd vs2 inm",
      "co": "1010111",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vadd.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "function vaddVI(vd, vs2, inm) {for (let i = 0; i < checkVl(); ++i) {\nvd[i] = vs2[i] + inm;}\n return vd;}\nvd = vecIntOperation(vd, vs2, inm, vaddVI);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsub.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F3 F2 F1 v0.t",
      "signature": "vsub.vi,VEC-Reg,VEC-Reg,inm-signed,v0.t",
      "signatureRaw": "vsub.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsub.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function vsubVI(vd, vs2, inm) {\nfor (let i = 0; i < checkVl(); ++i) {vd[i] = vs2[i] - inm;}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, inm, vd, vecIntOperationWrapperFactory(vsubVI));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsub.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "vsub.vi,VEC-Reg,VEC-Reg,inm-signed",
      "signatureRaw": "vsub.vi vd vs2 inm",
      "co": "1010111",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsub.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "function vsubVI(vd, vs2, inm) {\nfor (let i = 0; i < checkVl(); ++i) {vd[i] = vs2[i] - inm;\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, inm, vsubVI);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vse8.v",
      "type": "Memory access",
      "signature_definition": "F0 F2 F1 (F3) v0.t",
      "signature": "vse8.v,VEC-Reg,inm-unsigned,(INT-Reg) v0.t",
      "signatureRaw": "vse8.v vd inm (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vse8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stoptbit": 25
        }
      ],
      "definition": "maskedMemoryOperation(checkVl(), rs1+inm, 'vector8', vd_name, 'store', vd);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vrsub.vx",
      "type": "Memory access",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vrsub.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vrsub.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vrsub.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function rsub(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 - vs2[i];\n}\n\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, rs1, vd, vecIntOperationWrapperFactory(rsub));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vrsub.vx",
      "type": "Memory access",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vrsub.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vrsub.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vrsub.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function rsub(vd, vs2, rs1) {\n\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 - vs2[i];\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, rs1, rsub);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vse8.v",
      "type": "Memory access",
      "signature_definition": "F0 F2 F1 (F3)",
      "signature": "vse8.v,VEC-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "vse8.v vd inm (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vse8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "capi_mem_write(inm+rs1, vd, 'vector8', vd_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vse16.v",
      "type": "Memory access",
      "signature_definition": "F0 F2 F1 (F3) v0.t",
      "signature": "vse16.v,VEC-Reg,inm-unsigned,(INT-Reg) v0.t",
      "signatureRaw": "vse16.v vd inm (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vse16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stoptbit": 25
        }
      ],
      "definition": "maskedMemoryOperation(checkVl(), rs1+inm, 'vector16', vd_name, 'store', vd);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vse16.v",
      "type": "Memory access",
      "signature_definition": "F0 F2 F1 (F3)",
      "signature": "vse16.v,VEC-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "vse16.v vd inm (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vse16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "capi_mem_write(inm+rs1, vd, 'vector16', vd_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vse32.v",
      "type": "Memory access",
      "signature_definition": "F0 F2 F1 (F3) v0.t",
      "signature": "vse32.v,VEC-Reg,inm-unsigned,(INT-Reg) v0.t",
      "signatureRaw": "vse32.v vd inm (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vse32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stoptbit": 25
        }
      ],
      "definition": "maskedMemoryOperation(checkVl(), rs1+inm, 'vector32', vd_name, 'store', vd);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vse32.v",
      "type": "Memory access",
      "signature_definition": "F0 F2 F1 (F3)",
      "signature": "vse32.v,VEC-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "vse32.v vd inm (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vse32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "capi_mem_write(inm+rs1, vd, 'vector32', vd_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vse64.v",
      "type": "Memory access",
      "signature_definition": "F0 F2 F1 (F3) v0.t",
      "signature": "vse64.v,VEC-Reg,inm-unsigned,(INT-Reg) v0.t",
      "signatureRaw": "vse64.v vd inm (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vse64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stoptbit": 25
        }
      ],
      "definition": "maskedMemoryOperation(checkVl(), rs1+inm, 'vector64', vd_name, 'store', vd);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vse64.v",
      "type": "Memory access",
      "signature_definition": "F0 F2 F1 (F3)",
      "signature": "vse64.v,VEC-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "vse64.v vd inm (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vse64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "capi_mem_write(inm+rs1, vd, 'vector64', vd_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vle8.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2) v0.t",
      "signature": "vle8.v,VEC-Reg,inm-unsigned,(INT-Reg),v0.t",
      "signatureRaw": "vle8.v rd inm (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vle8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "var addr = capi_int2uint(rs1)+inm;\n rd = maskedMemoryOperation(checkVl(), addr, 'vector8', rd_name, 'load')",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vle8.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2)",
      "signature": "vle8.v,VEC-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "vle8.v rd inm (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vle8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "var addr = capi_int2uint(rs1)+inm;\n rd = capi_mem_read(addr, 'vector8', rd_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vle16.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2) v0.t",
      "signature": "vle16.v,VEC-Reg,inm-unsigned,(INT-Reg),v0.t",
      "signatureRaw": "vle16.v rd inm (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vle16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "var addr = capi_int2uint(rs1)+inm;\n rd = maskedMemoryOperation(checkVl(), addr, 'vector16', rd_name, 'load')",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vle16.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2)",
      "signature": "vle16.v,VEC-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "vle16.v rd inm (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vle16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "var addr = capi_int2uint(rs1)+inm;\n rd = capi_mem_read(addr, 'vector16', rd_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vle32.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2) v0.t",
      "signature": "vle32.v,VEC-Reg,inm-unsigned,(INT-Reg),v0.t",
      "signatureRaw": "vle32.v rd inm (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vle32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "var addr = capi_int2uint(rs1)+inm;\n rd = maskedMemoryOperation(checkVl(), addr, 'vector32', rd_name, 'load')",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vle32.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2)",
      "signature": "vle8.v,VEC-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "vle32.v rd inm (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vle32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "var addr = capi_int2uint(rs1)+inm;\n rd = capi_mem_read(addr, 'vector32', rd_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vle64.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2) v0.t",
      "signature": "vle64.v,VEC-Reg,inm-unsigned,(INT-Reg),v0.t",
      "signatureRaw": "vle64.v rd inm (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vle64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "var addr = capi_int2uint(rs1)+inm;\n rd = maskedMemoryOperation(checkVl(), addr, 'vector64', rd_name, 'load')",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vle64.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2)",
      "signature": "vle64.v,VEC-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "vle64.v rd inm (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vle64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "var addr = capi_int2uint(rs1)+inm;\n rd = capi_mem_read(addr, 'vector64', rd_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlse8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlse8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vlse8.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlse8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask = extractMaskFromV0(checkVl());\nvd = vectorStridedLoad(vd, rs1, rs2, 8, vl, mask);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlse16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlse16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vlse16.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlse16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask = extractMaskFromV0(checkVl());\nvd = vectorStridedLoad(vd, rs1, rs2, 16, vl, mask);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlse32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlse32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vlse32.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlse32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask = extractMaskFromV0(checkVl());\nvd = vectorStridedLoad(vd, rs1, rs2, 32, vl, mask);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlse64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlse64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vlse64.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlse64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask = extractMaskFromV0(checkVl());\nvd = vectorStridedLoad(vd, rs1, rs2, 64, vl, mask);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlse8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlse8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vlse8.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlse8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "vd = vectorStridedLoad(vd, rs1, rs2, 8, vl);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlse16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlse16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vlse16.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlse16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "vd = vectorStridedLoad(vd, rs1, rs2, 16, vl);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlse32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlse32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vlse32.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlse32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "vd = vectorStridedLoad(vd, rs1, rs2, 32, vl);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlse64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlse64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vlse64.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlse64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "vd = vectorStridedLoad(vd, rs1, rs2, 64, vl);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsse8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsse8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsse8.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsse8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask = extractMaskFromV0(checkVl());\nvectorStridedStore(vs3, rs1, rs2, 8, vl, mask);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsse16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsse16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsse16.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsse16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask = extractMaskFromV0(checkVl());\nvectorStridedStore(vs3, rs1, rs2, 16, vl, mask);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsse32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsse32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsse32.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsse32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask = extractMaskFromV0(checkVl());\nvectorStridedStore(vs3, rs1, rs2, 32, vl, mask);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsse64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsse64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsse64.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsse64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask = extractMaskFromV0(checkVl());\nvectorStridedStore(vs3, rs1, rs2, 64, vl, mask);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsse8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsse8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsse8.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsse8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "vectorStridedStore(vs3, rs1, rs2, 8, vl);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsse16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsse16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsse16.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsse16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "vectorStridedStore(vs3, rs1, rs2, 16, vl);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsse32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsse32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsse32.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsse32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "vectorStridedStore(vs3, rs1, rs2, 32, vl);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsse64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsse64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsse64.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsse64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "vectorStridedStore(vs3, rs1, rs2, 64, vl);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vloxei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1 v0.t",
      "signature": "vloxei8.v,VEC-Reg,(INT-Reg),VEC-Reg v0.t",
      "signatureRaw": "vloxei8.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vloxei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let mem = capi_mem_read(rs1, 'vector8');\nlet backup = [...vd];\nfor(let i=0; i < checkVl(); ++i) {vd[vs2[i]] = mem[i];}\nvd = applyMask(extractMaskFromV0(checkVl()), checkMA(), vd, backup, checkVl());",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vloxei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1 v0.t",
      "signature": "vloxei16.v,VEC-Reg,(INT-Reg),VEC-Reg v0.t",
      "signatureRaw": "vloxei16.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vloxei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let mem = capi_mem_read(rs1, 'vector16');\nlet backup = [...vd];\nfor(let i=0; i < checkVl(); ++i) {vd[vs2[i]] = mem[i];}\nvd = applyMask(extractMaskFromV0(checkVl()), checkMA(), vd, backup, checkVl());",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vloxei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1 v0.t",
      "signature": "vloxei32.v,VEC-Reg,(INT-Reg),VEC-Reg v0.t",
      "signatureRaw": "vloxei32.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vloxei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let mem = capi_mem_read(rs1, 'vector32');\nlet backup = [...vd];\nfor(let i=0; i < checkVl(); ++i) {vd[vs2[i]] = mem[i];}\nvd = applyMask(extractMaskFromV0(checkVl()), checkMA(), vd, backup, checkVl());",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vloxei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1 v0.t",
      "signature": "vloxei64.v,VEC-Reg,(INT-Reg),VEC-Reg v0.t",
      "signatureRaw": "vloxei64.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vloxei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let mem = capi_mem_read(rs1, 'vector64');\nlet backup = [...vd];\nfor(let i=0; i < checkVl(); ++i) {vd[vs2[i]] = mem[i];}\nvd = applyMask(extractMaskFromV0(checkVl()), checkMA(), vd, backup, checkVl());",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vloxei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1",
      "signature": "vloxei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vloxei8.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vloxei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "\n let mem = capi_mem_read(rs1, 'vector8');\n for(let i=0; i < checkVl(); ++i) {vd[vs2[i]] = mem[i];}",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vloxei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1",
      "signature": "vloxei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vloxei16.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vloxei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let mem = capi_mem_read(rs1, 'vector16');\nfor(let i=0; i < checkVl(); ++i) {vd[vs2[i]] = mem[i];}",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vloxei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1",
      "signature": "vloxei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vloxei32.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vloxei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let mem = capi_mem_read(rs1, 'vector32');\n for(let i=0; i < checkVl(); ++i) {vd[vs2[i]] = mem[i];}",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vloxei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1",
      "signature": "vloxei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vloxei64.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vloxei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let mem = capi_mem_read(rs1, 'vector64');\n for(let i=0; i < checkVl(); ++i) {vd[vs2[i]] = mem[i];}",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsoxei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1 v0.t",
      "signature": "vsoxei8.v,VEC-Reg,(INT-Reg),VEC-Reg v0.t",
      "signatureRaw": "vsoxei8.v vd (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsoxei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let mem = capi_mem_read(rs1, 'vector8');\nlet backup = [...mem];\nfor(let i=0; i < checkVl(); ++i) {mem[vs2[i]] = vd[i];}\nmem = applyMask(extractMaskFromV0(checkVl()), checkMA(), mem, backup, checkVl());\ncapi_mem_write(rs1, mem, 'vector8', vd_name)",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsoxei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1 v0.t",
      "signature": "vsoxei16.v,VEC-Reg,(INT-Reg),VEC-Reg v0.t",
      "signatureRaw": "vsoxei16.v vd (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsoxei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let vecType='vector16';\nlet mem = capi_mem_read(rs1, vecType);\nlet backup = [...mem];\nfor(let i=0; i < checkVl(); ++i) {mem[vs2[i]] = vd[i];}\nmem = applyMask(extractMaskFromV0(checkVl()), checkMA(), mem, backup, checkVl());\ncapi_mem_write(rs1, mem, vecType, vd_name)",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsoxei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1 v0.t",
      "signature": "vsoxei32.v,VEC-Reg,(INT-Reg),VEC-Reg v0.t",
      "signatureRaw": "vsoxei32.v vd (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsoxei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let vecType = 'vector32';\nlet mem = capi_mem_read(rs1, vecType);\nlet backup = [...mem];\nfor(let i=0; i < checkVl(); ++i) {mem[vs2[i]] = vd[i];}\nmem = applyMask(extractMaskFromV0(checkVl()), checkMA(), mem, backup, checkVl());\ncapi_mem_write(rs1, mem, vecType, vd_name)",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsoxei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1 v0.t",
      "signature": "vsoxei64.v,VEC-Reg,(INT-Reg),VEC-Reg v0.t",
      "signatureRaw": "vsoxei64.v vd (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsoxei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "v0.t",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let vecType = 'vector64';\nlet mem = capi_mem_read(rs1, vecType);\nlet backup = [...mem];\nfor(let i=0; i < checkVl(); ++i) {mem[vs2[i]] = vd[i];}\nmem = applyMask(extractMaskFromV0(checkVl()), checkMA(), mem, backup, checkVl());\ncapi_mem_write(rs1, mem, vecType, vd_name)",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsoxei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1",
      "signature": "vsoxei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsoxei8.v vs1 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsoxei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let aux = fixVectorLength([], checkVl());\nfor (let i = 0; i < checkVl(); ++i) {\naux[vs2[i]] = vs1[i];\n}\ncapi_mem_write(rs1, aux, 'vector8', vs1_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsoxei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1",
      "signature": "vsoxei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsoxei16.v vs1 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsoxei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let aux = fixVectorLength([], checkVl());\nfor (let i = 0; i < checkVl(); ++i) {\naux[vs2[i]] = vs1[i];}\ncapi_mem_write(rs1, aux, 'vector16', vs1_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsoxei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1",
      "signature": "vsoxei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsoxei32.v vs1 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsoxei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let aux = fixVectorLength([], checkVl());\nfor (let i = 0; i < checkVl(); ++i) {\naux[vs2[i]] = vs1[i];}\ncapi_mem_write(rs1, aux, 'vector32', vs1_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsoxei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F3 (F2) F1",
      "signature": "vsoxei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsoxei64.v vs1 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsoxei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "let aux = fixVectorLength([], checkVl());\nfor (let i = 0; i < checkVl(); ++i) {\naux[vs2[i]] = vs1[i];}\ncapi_mem_write(rs1, aux, 'vector64', vs1_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg1e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg1e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg1e8.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg1e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 1, 8, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg1e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg1e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg1e16.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg1e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 2, 16, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg1e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg1e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg1e32.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg1e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 4, 32, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg1e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg1e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg1e64.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg1e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 8, 64, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg2e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg2e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg2e8.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg2e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 2, 8, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg2e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg2e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg2e16.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg2e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 4, 16, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg2e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg2e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg2e32.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg2e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 8, 32, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg2e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg2e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg2e64.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg2e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 16, 64, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg3e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg3e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg3e8.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg3e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 3, 8, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg3e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg3e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg3e16.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg3e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 6, 16, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg3e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg3e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg3e32.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg3e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 12, 32, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg3e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg3e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg3e64.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg3e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 24, 64, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg4e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg4e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg4e8.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg4e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 4, 8, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg4e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg4e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg4e16.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg4e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 8, 16, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg4e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg4e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg4e32.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg4e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 16, 32, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg4e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg4e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg4e64.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg4e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 32, 64, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg5e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg5e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg5e8.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg5e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 5, 8, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg5e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg5e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg5e16.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg5e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 10, 16, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg5e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg5e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg5e32.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg5e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 20, 32, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg5e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg5e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg5e64.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg5e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 40, 64, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg6e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg6e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg6e8.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg6e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 6, 8, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg6e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg6e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg6e16.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg6e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 12, 16, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg6e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg6e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg6e32.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg6e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 24, 32, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg6e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg6e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg6e64.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg6e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 48, 64, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg7e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg7e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg7e8.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg7e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 7, 8, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg7e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg7e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg7e16.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg7e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 14, 16, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg7e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg7e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg7e32.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg7e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 28, 32, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg7e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg7e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg7e64.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg7e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 56, 64, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg8e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg8e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg8e8.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg8e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 8, 8, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg8e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg8e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg8e16.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg8e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 16, 16, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg8e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg8e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg8e32.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg8e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 32, 32, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg8e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vlseg8e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vlseg8e64.v vd (rs1) v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg8e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 64, 64, checkVl(), mask);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg1e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg1e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg1e8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg1e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 1, 8, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg1e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg1e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg1e16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg1e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 2, 16, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg1e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg1e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg1e32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg1e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 4, 32, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg1e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg1e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg1e64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg1e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 8, 64, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg2e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg2e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg2e8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg2e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 2, 8, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg2e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg2e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg2e16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg2e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 4, 16, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg2e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg2e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg2e32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg2e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 8, 32, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg2e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg2e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg2e64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg2e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 16, 64, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg3e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg3e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg3e8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg3e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 3, 8, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg3e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg3e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg3e16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg3e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 6, 16, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg3e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg3e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg3e32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg3e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 12, 32, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg3e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg3e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg3e64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg3e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 24, 64, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg4e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg4e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg4e8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg4e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 4, 8, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg4e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg4e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg4e16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg4e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 8, 16, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg4e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg4e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg4e32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg4e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 16, 32, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg4e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg4e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg4e64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg4e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 32, 64, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg5e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg5e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg5e8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg5e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 5, 8, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg5e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg5e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg5e16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg5e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 10, 16, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg5e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg5e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg5e32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg5e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 20, 32, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg5e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg5e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg5e64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg5e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 40, 64, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg6e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg6e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg6e8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg6e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 6, 8, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg6e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg6e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg6e16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg6e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 12, 16, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg6e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg6e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg6e32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg6e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 24, 32, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg6e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg6e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg6e64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg6e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 48, 64, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg7e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg7e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg7e8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg7e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 7, 8, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg7e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg7e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg7e16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg7e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 14, 16, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg7e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg7e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg7e32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg7e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 28, 32, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg7e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg7e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg7e64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg7e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 56, 64, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg8e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg8e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg8e8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg8e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*1, 8, 8, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg8e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg8e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg8e16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg8e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*2, 16, 16, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg8e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg8e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg8e32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg8e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*4, 32, 32, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlseg8e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vlseg8e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vlseg8e64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlseg8e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedLoad(curr_reg, rs1 + i*8, 64, 64, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg1e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg1e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg1e8.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg1e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg1e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg1e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg1e16.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg1e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg1e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg1e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg1e32.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg1e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg1e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg1e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg1e64.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg1e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg2e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg2e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg2e8.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg2e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg2e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg2e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg2e16.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg2e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg2e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg2e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg2e32.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg2e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg2e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg2e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg2e64.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg2e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg3e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg3e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg3e8.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg3e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg3e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg3e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg3e16.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg3e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg3e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg3e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg3e32.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg3e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg3e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg3e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg3e64.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg3e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg4e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg4e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg4e8.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg4e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg4e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg4e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg4e16.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg4e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg4e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg4e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg4e32.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg4e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg4e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg4e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg4e64.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg4e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg5e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg5e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg5e8.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg5e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg5e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg5e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg5e16.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg5e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg5e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg5e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg5e32.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg5e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg5e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg5e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg5e64.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg5e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg6e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg6e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg6e8.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg6e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg6e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg6e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg6e16.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg6e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg6e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg6e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg6e32.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg6e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg6e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg6e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg6e64.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg6e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg7e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg7e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg7e8.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg7e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg7e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg7e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg7e16.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg7e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg7e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg7e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg7e32.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg7e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg7e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg7e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg7e64.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg7e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg8e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg8e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg8e8.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg8e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg8e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg8e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg8e16.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg8e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg8e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg8e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg8e32.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg8e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg8e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vlsseg8e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vlsseg8e64.v vd (rs1) rs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg8e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nlet backup = [...curr_reg];\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\ncurr_reg = applyMask(mask, checkMA(), curr_reg, backup, checkVl());\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg1e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg1e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg1e8.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg1e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg1e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg1e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg1e16.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg1e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg1e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg1e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg1e32.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg1e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg1e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg1e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg1e64.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg1e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg2e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg2e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg2e8.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg2e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg2e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg2e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg2e16.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg2e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg2e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg2e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg2e32.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg2e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg2e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg2e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg2e64.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg2e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg3e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg3e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg3e8.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg3e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg3e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg3e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg3e16.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg3e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg3e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg3e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg3e32.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg3e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg3e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg3e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg3e64.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg3e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg4e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg4e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg4e8.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg4e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg4e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg4e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg4e16.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg4e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg4e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg4e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg4e32.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg4e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg4e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg4e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg4e64.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg4e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg5e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg5e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg5e8.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg5e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg5e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg5e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg5e16.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg5e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg5e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg5e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg5e32.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg5e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg5e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg5e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg5e64.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg5e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg6e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg6e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg6e8.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg6e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg6e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg6e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg6e16.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg6e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg6e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg6e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg6e32.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg6e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg6e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg6e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg6e64.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg6e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg7e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg7e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg7e8.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg7e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg7e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg7e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg7e16.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg7e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg7e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg7e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg7e32.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg7e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg7e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg7e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg7e64.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg7e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg8e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg8e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg8e8.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg8e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*1 + (rs1 + j*rs2), '8');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg8e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg8e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg8e16.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg8e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*2 + (rs1 + j*rs2), '16');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg8e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg8e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg8e32.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg8e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*4 + (rs1 + j*rs2), '32');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vlsseg8e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vlsseg8e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vlsseg8e64.v vd (rs1) rs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vlsseg8e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet mem = capi_mem_read(i*8 + (rs1 + j*rs2), '64');\ncurr_reg[j] = mem;\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg1ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg1ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg1ei8.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg1ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg1ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg1ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg1ei16.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg1ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg1ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg1ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg1ei32.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg1ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg1ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg1ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg1ei64.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg1ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg2ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg2ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg2ei8.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg2ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg2ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg2ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg2ei16.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg2ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg2ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg2ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg2ei32.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg2ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg2ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg2ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg2ei64.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg2ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg3ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg3ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg3ei8.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg3ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg3ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg3ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg3ei16.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg3ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg3ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg3ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg3ei32.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg3ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg3ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg3ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg3ei64.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg3ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg4ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg4ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg4ei8.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg4ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg4ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg4ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg4ei16.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg4ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg4ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg4ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg4ei32.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg4ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg4ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg4ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg4ei64.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg4ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg5ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg5ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg5ei8.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg5ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg5ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg5ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg5ei16.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg5ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg5ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg5ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg5ei32.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg5ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg5ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg5ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg5ei64.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg5ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg6ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg6ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg6ei8.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg6ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg6ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg6ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg6ei16.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg6ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg6ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg6ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg6ei32.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg6ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg6ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg6ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg6ei64.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg6ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg7ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg7ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg7ei8.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg7ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg7ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg7ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg7ei16.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg7ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg7ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg7ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg7ei32.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg7ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg7ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg7ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg7ei64.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg7ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg8ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg8ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg8ei8.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg8ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg8ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg8ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg8ei16.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg8ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg8ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg8ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg8ei32.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg8ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg8ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vluxseg8ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vluxseg8ei64.v vd (rs1) vs2 v0.t",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg8ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\n\nlet mask = extractMaskFromV0(vector_length);\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\nlet backup = [...curr_reg];\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\ncurr_reg = applyMask(mask, checkMA(),curr_reg, backup, vector_length);\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg1ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg1ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg1ei8.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg1ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg1ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg1ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg1ei16.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg1ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg1ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg1ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg1ei32.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg1ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg1ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg1ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg1ei64.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg1ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg2ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg2ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg2ei8.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg2ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg2ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg2ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg2ei16.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg2ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg2ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg2ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg2ei32.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg2ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg2ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg2ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg2ei64.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg2ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg3ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg3ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg3ei8.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg3ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg3ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg3ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg3ei16.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg3ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg3ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg3ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg3ei32.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg3ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg3ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg3ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg3ei64.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg3ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg4ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg4ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg4ei8.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg4ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg4ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg4ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg4ei16.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg4ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg4ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg4ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg4ei32.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg4ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg4ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg4ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg4ei64.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg4ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg5ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg5ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg5ei8.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg5ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg5ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg5ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg5ei16.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg5ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg5ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg5ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg5ei32.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg5ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg5ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg5ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg5ei64.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg5ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg6ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg6ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg6ei8.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg6ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg6ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg6ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg6ei16.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg6ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg6ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg6ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg6ei32.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg6ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg6ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg6ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg6ei64.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg6ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg7ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg7ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg7ei8.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg7ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg7ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg7ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg7ei16.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg7ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg7ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg7ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg7ei32.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg7ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg7ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg7ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg7ei64.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg7ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg8ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg8ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg8ei8.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg8ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*1), 'vector8');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg8ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg8ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg8ei16.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg8ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*2), 'vector16');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg8ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg8ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg8ei32.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg8ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*4), 'vector32');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vluxseg8ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vluxseg8ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vluxseg8ei64.v vd (rs1) vs2",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vluxseg8ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0,
          "valueField": "010"
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7,
          "valueField": "010"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "010"
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nlet vector_length = checkVl();\nfor (let i = 0; i < nf; ++i) {\nlet mem = capi_mem_read(rs1 + i*(vector_length*8), 'vector64');\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let e=0; e < vector_length; ++e) {\ncurr_reg[vs2[e]] = mem[e];\n}\nwriteRegister(curr_reg, base_reg.indexComp, base_reg.indexElem + i);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg1e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg1e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg1e8.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg1e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 1, 8, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg1e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg1e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg1e16.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg1e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 2, 16, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg1e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg1e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg1e32.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg1e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 4, 32, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg1e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg1e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg1e64.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg1e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 8, 64, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg2e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg2e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg2e8.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg2e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 2, 8, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg2e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg2e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg2e16.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg2e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 4, 16, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg2e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg2e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg2e32.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg2e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 8, 32, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg2e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg2e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg2e64.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg2e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 16, 64, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg3e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg3e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg3e8.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg3e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 3, 8, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg3e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg3e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg3e16.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg3e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 6, 16, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg3e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg3e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg3e32.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg3e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 12, 32, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg3e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg3e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg3e64.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg3e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 24, 64, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg4e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg4e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg4e8.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg4e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 4, 8, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg4e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg4e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg4e16.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg4e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 8, 16, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg4e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg4e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg4e32.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg4e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 16, 32, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg4e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg4e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg4e64.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg4e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 32, 64, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg5e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg5e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg5e8.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg5e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 5, 8, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg5e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg5e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg5e16.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg5e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 10, 16, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg5e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg5e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg5e32.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg5e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 20, 32, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg5e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg5e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg5e64.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg5e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 40, 64, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg6e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg6e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg6e8.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg6e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 6, 8, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg6e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg6e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg6e16.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg6e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 12, 16, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg6e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg6e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg6e32.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg6e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 24, 32, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg6e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg6e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg6e64.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg6e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 48, 64, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg7e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg7e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg7e8.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg7e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 7, 8, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg7e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg7e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg7e16.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg7e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 14, 16, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg7e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg7e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg7e32.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg7e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 28, 32, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg7e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg7e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg7e64.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg7e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 56, 64, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg8e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg8e8.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg8e8.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg8e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 8, 8, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg8e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg8e16.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg8e16.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg8e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 16, 16, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg8e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg8e32.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg8e32.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg8e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 32, 32, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg8e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) v0.t",
      "signature": "vsseg8e64.v,VEC-Reg,(INT-Reg),v0.t",
      "signatureRaw": "vsseg8e64.v vd (rs1) v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg8e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8\nlet base_reg = crex_findReg(vd_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 64, 64, checkVl(), mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg1e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg1e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg1e8.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg1e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 1, 8, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg1e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg1e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg1e16.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg1e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 2, 16, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg1e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg1e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg1e32.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg1e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 4, 32, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg1e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg1e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg1e64.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg1e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 8, 64, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg2e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg2e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg2e8.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg2e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 2, 8, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg2e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg2e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg2e16.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg2e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 4, 16, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg2e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg2e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg2e32.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg2e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 8, 32, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg2e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg2e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg2e64.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg2e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 16, 64, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg3e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg3e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg3e8.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg3e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 3, 8, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg3e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg3e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg3e16.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg3e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 6, 16, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg3e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg3e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg3e32.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg3e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 12, 32, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg3e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg3e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg3e64.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg3e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 24, 64, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg4e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg4e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg4e8.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg4e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 4, 8, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg4e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg4e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg4e16.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg4e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 8, 16, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg4e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg4e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg4e32.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg4e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 16, 32, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg4e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg4e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg4e64.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg4e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 32, 64, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg5e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg5e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg5e8.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg5e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 5, 8, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg5e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg5e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg5e16.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg5e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 10, 16, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg5e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg5e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg5e32.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg5e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 20, 32, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg5e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg5e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg5e64.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg5e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 40, 64, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg6e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg6e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg6e8.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg6e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 6, 8, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg6e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg6e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg6e16.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg6e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 12, 16, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg6e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg6e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg6e32.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg6e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 24, 32, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg6e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg6e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg6e64.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg6e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 48, 64, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg7e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg7e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg7e8.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg7e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 7, 8, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg7e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg7e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg7e16.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg7e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 14, 16, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg7e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg7e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg7e32.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg7e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 28, 32, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg7e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg7e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg7e64.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg7e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 56, 64, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg8e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg8e8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg8e8.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg8e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*1, 8, 8, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg8e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg8e16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg8e16.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg8e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*2, 16, 16, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg8e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg8e32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg8e32.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg8e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*4, 32, 32, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsseg8e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vsseg8e64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vsseg8e64.v vd (rs1)",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsseg8e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i, 'VEC-Reg');\ncurr_reg = vectorStridedStore(curr_reg, rs1 + i*8, 64, 64, checkVl());\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg1e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg1e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg1e8.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg1e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 1);\n}\n}\nmain_memory_write_nbytes(insert, value, 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg1e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg1e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg1e16.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg1e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 2);\n}\n}\nmain_memory_write_nbytes(insert, value, 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg1e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg1e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg1e32.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg1e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 4);\n}\n}\nmain_memory_write_nbytes(insert, value, 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg1e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg1e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg1e64.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg1e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 8);\n}\n}\nmain_memory_write_nbytes(insert, value, 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg2e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg2e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg2e8.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg2e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 1);\n}\n}\nmain_memory_write_nbytes(insert, value, 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg2e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg2e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg2e16.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg2e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 2);\n}\n}\nmain_memory_write_nbytes(insert, value, 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg2e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg2e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg2e32.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg2e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 4);\n}\n}\nmain_memory_write_nbytes(insert, value, 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg2e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg2e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg2e64.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg2e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 8);\n}\n}\nmain_memory_write_nbytes(insert, value, 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg3e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg3e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg3e8.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg3e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 1);\n}\n}\nmain_memory_write_nbytes(insert, value, 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg3e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg3e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg3e16.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg3e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 2);\n}\n}\nmain_memory_write_nbytes(insert, value, 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg3e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg3e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg3e32.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg3e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 4);\n}\n}\nmain_memory_write_nbytes(insert, value, 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg3e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg3e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg3e64.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg3e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 8);\n}\n}\nmain_memory_write_nbytes(insert, value, 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg4e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg4e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg4e8.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg4e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 1);\n}\n}\nmain_memory_write_nbytes(insert, value, 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg4e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg4e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg4e16.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg4e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 2);\n}\n}\nmain_memory_write_nbytes(insert, value, 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg4e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg4e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg4e32.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg4e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 4);\n}\n}\nmain_memory_write_nbytes(insert, value, 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg4e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg4e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg4e64.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg4e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 8);\n}\n}\nmain_memory_write_nbytes(insert, value, 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg5e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg5e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg5e8.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg5e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 1);\n}\n}\nmain_memory_write_nbytes(insert, value, 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg5e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg5e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg5e16.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg5e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 2);\n}\n}\nmain_memory_write_nbytes(insert, value, 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg5e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg5e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg5e32.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg5e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 4);\n}\n}\nmain_memory_write_nbytes(insert, value, 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg5e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg5e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg5e64.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg5e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 8);\n}\n}\nmain_memory_write_nbytes(insert, value, 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg6e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg6e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg6e8.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg6e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 1);\n}\n}\nmain_memory_write_nbytes(insert, value, 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg6e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg6e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg6e16.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg6e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 2);\n}\n}\nmain_memory_write_nbytes(insert, value, 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg6e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg6e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg6e32.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg6e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 4);\n}\n}\nmain_memory_write_nbytes(insert, value, 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg6e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg6e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg6e64.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg6e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 8);\n}\n}\nmain_memory_write_nbytes(insert, value, 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg7e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg7e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg7e8.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg7e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 1);\n}\n}\nmain_memory_write_nbytes(insert, value, 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg7e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg7e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg7e16.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg7e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 2);\n}\n}\nmain_memory_write_nbytes(insert, value, 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg7e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg7e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg7e32.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg7e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 4);\n}\n}\nmain_memory_write_nbytes(insert, value, 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg7e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg7e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg7e64.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg7e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 8);\n}\n}\nmain_memory_write_nbytes(insert, value, 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg8e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg8e8.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg8e8.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg8e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 1);\n}\n}\nmain_memory_write_nbytes(insert, value, 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg8e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg8e16.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg8e16.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg8e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 2);\n}\n}\nmain_memory_write_nbytes(insert, value, 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg8e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg8e32.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg8e32.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg8e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 4);\n}\n}\nmain_memory_write_nbytes(insert, value, 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg8e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vssseg8e64.v,VEC-Reg,(INT-Reg),INT-Reg,v0.t",
      "signatureRaw": "vssseg8e64.v vs3 (rs1) rs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg8e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nlet value = curr_reg[j];\nif (!mask[j]) {\nif (checkMA()) {\nvalue = -1n;\n} else {\nvalue = main_memory_read_nbytes(insert, 8);\n}\n}\nmain_memory_write_nbytes(insert, value, 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg1e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg1e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg1e8.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg1e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg1e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg1e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg1e16.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg1e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg1e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg1e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg1e32.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg1e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg1e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg1e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg1e64.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg1e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg2e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg2e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg2e8.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg2e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg2e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg2e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg2e16.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg2e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg2e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg2e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg2e32.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg2e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg2e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg2e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg2e64.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg2e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg3e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg3e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg3e8.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg3e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg3e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg3e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg3e16.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg3e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg3e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg3e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg3e32.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg3e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg3e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg3e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg3e64.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg3e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg4e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg4e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg4e8.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg4e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg4e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg4e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg4e16.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg4e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg4e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg4e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg4e32.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg4e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg4e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg4e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg4e64.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg4e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg5e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg5e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg5e8.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg5e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg5e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg5e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg5e16.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg5e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg5e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg5e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg5e32.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg5e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg5e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg5e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg5e64.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg5e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg6e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg6e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg6e8.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg6e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg6e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg6e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg6e16.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg6e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg6e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg6e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg6e32.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg6e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg6e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg6e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg6e64.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg6e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg7e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg7e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg7e8.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg7e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg7e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg7e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg7e16.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg7e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg7e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg7e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg7e32.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg7e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg7e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg7e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg7e64.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg7e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg8e8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg8e8.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg8e8.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg8e8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*1 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 1);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg8e16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg8e16.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg8e16.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg8e16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*2 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 2);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg8e32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg8e32.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg8e32.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg8e32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*4 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 4);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vssseg8e64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vssseg8e64.v,VEC-Reg,(INT-Reg),INT-Reg",
      "signatureRaw": "vssseg8e64.v vs3 (rs1) rs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vssseg8e64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nfor (let j = 0; j < checkVl(); ++j) {\nlet insert = i*8 + (rs1 + j*rs2);\nmain_memory_write_nbytes(insert, curr_reg[j], 8);\n}\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg1ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg1ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg1ei8.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg1ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg1ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg1ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg1ei16.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg1ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg1ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg1ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg1ei32.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg1ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg1ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg1ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg1ei64.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg1ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg2ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg2ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg2ei8.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg2ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg2ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg2ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg2ei16.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg2ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg2ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg2ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg2ei32.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg2ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg2ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg2ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg2ei64.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg2ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg3ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg3ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg3ei8.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg3ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg3ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg3ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg3ei16.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg3ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg3ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg3ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg3ei32.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg3ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg3ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg3ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg3ei64.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg3ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg4ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg4ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg4ei8.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg4ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg4ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg4ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg4ei16.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg4ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg4ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg4ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg4ei32.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg4ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg4ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg4ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg4ei64.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg4ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg5ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg5ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg5ei8.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg5ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg5ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg5ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg5ei16.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg5ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg5ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg5ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg5ei32.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg5ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg5ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg5ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg5ei64.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg5ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg6ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg6ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg6ei8.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg6ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg6ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg6ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg6ei16.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg6ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg6ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg6ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg6ei32.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg6ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg6ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg6ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg6ei64.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg6ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg7ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg7ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg7ei8.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg7ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg7ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg7ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg7ei16.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg7ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg7ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg7ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg7ei32.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg7ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg7ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg7ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg7ei64.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg7ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg8ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg8ei8.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg8ei8.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg8ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg8ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg8ei16.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg8ei16.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg8ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg8ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg8ei32.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg8ei32.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg8ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg8ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3 v0.t",
      "signature": "vsuxseg8ei64.v,VEC-Reg,(INT-Reg),VEC-Reg,v0.t",
      "signatureRaw": "vsuxseg8ei64.v vs3 (rs1) vs2 v0.t",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg8ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nlet mask = extractMaskFromV0(checkVl());\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl, mask);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg1ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg1ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg1ei8.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg1ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg1ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg1ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg1ei16.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg1ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg1ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg1ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg1ei32.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg1ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg1ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg1ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg1ei64.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg1ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg2ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg2ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg2ei8.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg2ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg2ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg2ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg2ei16.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg2ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg2ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg2ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg2ei32.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg2ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg2ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg2ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg2ei64.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg2ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg3ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg3ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg3ei8.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg3ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg3ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg3ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg3ei16.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg3ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg3ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg3ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg3ei32.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg3ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg3ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg3ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg3ei64.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg3ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg4ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg4ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg4ei8.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg4ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg4ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg4ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg4ei16.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg4ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg4ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg4ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg4ei32.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg4ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg4ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg4ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg4ei64.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg4ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg5ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg5ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg5ei8.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg5ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg5ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg5ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg5ei16.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg5ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg5ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg5ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg5ei32.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg5ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg5ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg5ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg5ei64.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg5ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg6ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg6ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg6ei8.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg6ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg6ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg6ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg6ei16.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg6ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg6ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg6ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg6ei32.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg6ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg6ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg6ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg6ei64.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg6ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg7ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg7ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg7ei8.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg7ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg7ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg7ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg7ei16.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg7ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg7ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg7ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg7ei32.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg7ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg7ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg7ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg7ei64.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg7ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg8ei8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg8ei8.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg8ei8.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg8ei8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*1, 8, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg8ei16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg8ei16.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg8ei16.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg8ei16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*2, 16, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg8ei32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg8ei32.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg8ei32.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg8ei32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*4, 32, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsuxseg8ei64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2) F3",
      "signature": "vsuxseg8ei64.v,VEC-Reg,(INT-Reg),VEC-Reg",
      "signatureRaw": "vsuxseg8ei64.v vs3 (rs1) vs2",
      "co": "0100111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsuxseg8ei64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vs3",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vs3_name);\nfor (let i = 0; i < nf; ++i) {\nlet curr_reg = readRegister(base_reg.indexComp, base_reg.indexElem + i);\nvectorIndexStore(vs3, vs2, rs1 + i*8, 64, vl);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl1re8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl1re8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl1re8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl1re8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl1re16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl1re16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl1re16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl1re16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 16);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl1re32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl1re32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl1re32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl1re32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 32);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl1re64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl1re64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl1re64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl1re64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 64);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl2re8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl2re8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl2re8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl2re8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl2re16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl2re16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl2re16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl2re16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 16);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl2re32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl2re32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl2re32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl2re32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 32);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl2re64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl2re64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl2re64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl2re64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 64);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl3re8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl3re8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl3re8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl3re8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl3re16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl3re16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl3re16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl3re16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 16);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl3re32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl3re32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl3re32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl3re32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 32);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl3re64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl3re64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl3re64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl3re64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 64);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl4re8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl4re8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl4re8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl4re8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl4re16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl4re16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl4re16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl4re16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 16);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl4re32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl4re32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl4re32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl4re32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 32);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl4re64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl4re64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl4re64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl4re64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 64);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl5re8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl5re8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl5re8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl5re8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl5re16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl5re16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl5re16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl5re16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 16);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl5re32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl5re32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl5re32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl5re32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 32);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl5re64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl5re64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl5re64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl5re64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 64);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl6re8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl6re8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl6re8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl6re8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl6re16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl6re16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl6re16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl6re16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 16);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl6re32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl6re32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl6re32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl6re32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 32);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl6re64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl6re64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl6re64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl6re64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 64);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl7re8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl7re8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl7re8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl7re8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl7re16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl7re16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl7re16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl7re16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 16);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl7re32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl7re32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl7re32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl7re32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 32);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl7re64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl7re64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl7re64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl7re64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 64);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl8re8.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl8re8.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl8re8.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl8re8.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl8re16.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl8re16.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl8re16.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl8re16.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 16);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl8re32.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl8re32.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl8re32.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl8re32.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 32);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vl8re64.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vl8re64.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vl8re64.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vl8re64.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorLoadWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8, 64);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vs1r.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vs1r.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vs1r.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vs1r.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 1;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorStoreWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vs2r.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vs2r.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vs2r.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vs2r.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 2;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorStoreWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vs3r.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vs3r.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vs3r.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vs3r.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 3;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorStoreWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vs4r.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vs4r.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vs4r.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vs4r.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 4;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorStoreWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vs5r.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vs5r.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vs5r.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vs5r.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 5;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorStoreWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vs6r.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vs6r.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vs6r.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vs6r.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 6;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorStoreWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vs7r.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vs7r.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vs7r.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vs7r.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 7;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorStoreWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vs8r.v",
      "type": "Memory access",
      "signature_definition": "F0 F1 (F2)",
      "signature": "vs8r.v,VEC-Reg,(INT-Reg)",
      "signatureRaw": "vs8r.v vd (rs1)",
      "co": "0000111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vs8r.v",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let nf = 8;\nlet base_reg = crex_findReg(vd_name);\nfor (let i = 0; i < nf; ++i) {\nvectorStoreWhole(base_reg.indexComp, base_reg.indexElem + i, rs1 + i*checkVlen()/8);\n}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vrsub.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vrsub.vi,VEC-Reg,VEC-Reg,inm-signed,v0.t",
      "signatureRaw": "vrsub.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vrsub.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function rsub(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 - vs2[i];\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, inm, vd, vecIntOperationWrapperFactory(rsub));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vrsub.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vrsub.vi,VEC-Reg,VEC-Reg,inm-signed",
      "signatureRaw": "vrsub.vi vd vs2 inm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vrsub.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function rsub(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 - vs2[i];\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, inm, rsub);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vzext.vf2",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 v0.t",
      "signature": "vzext.vf2,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vzext.vf2 vd vs2 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vzext.vf2",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function zext(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nlet n = vs2[i] & ((1n << rs1) - 1n);\nvd[i] = n;\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, Math.floor(checkSEW()/2), vd, vecIntOperationWrapperFactory(zext));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vzext.vf4",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 v0.t",
      "signature": "vzext.vf4,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vzext.vf4 vd vs2 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vzext.vf4",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function zext(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nlet n = vs2[i] & ((1n << rs1) - 1n);\nvd[i] = n;\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, Math.floor(checkSEW()/4), vd, vecIntOperationWrapperFactory(zext));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vzext.vf8",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 v0.t",
      "signature": "vzext.vf8,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vzext.vf8 vd vs2 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vzext.vf8",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function zext(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nlet n = vs2[i] & ((1n << rs1) - 1n);\nvd[i] = n;\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, Math.floor(checkSEW()/8), vd, vecIntOperationWrapperFactory(zext));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vzext.vf2",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2",
      "signature": "vzext.vf2,VEC-Reg,VEC-Reg",
      "signatureRaw": "vzext.vf2 vd vs2",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vzext.vf2",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "function zext(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nlet n = vs2[i] & ((1n << rs1) - 1n);\nvd[i] = n;\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, Math.floor(checkSEW()/2), zext);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vzext.vf4",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2",
      "signature": "vzext.vf4,VEC-Reg,VEC-Reg",
      "signatureRaw": "vzext.vf4 vd vs2",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vzext.vf4",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "function zext(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nlet n = vs2[i] & ((1n << rs1) - 1n);\nvd[i] = n;\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, Math.floor(checkSEW()/4), zext);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vzext.vf8",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2",
      "signature": "vzext.vf8,VEC-Reg,VEC-Reg",
      "signatureRaw": "vzext.vf8 vd vs2",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vzext.vf8",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "function zext(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nlet n = vs2[i] & ((1n << rs1) - 1n);\nvd[i] = n;\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, Math.floor(checkSEW()/8), zext);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsext.vf2",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 v0.t",
      "signature": "vsext.vf2,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vsext.vf2 vd vs2 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsext.vf2",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function sext(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nlet n = vs2[i] & ((1n << rs1) - 1n);\nlet sign = (n & (1n << (rs1 - 1n)));\nn = (n ^ sign) - sign;\nvd[i] = n;\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, Math.floor(checkSEW()/2), vd, vecIntOperationWrapperFactory(sext));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsext.vf4",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 v0.t",
      "signature": "vsext.vf4,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vsext.vf4 vd vs2 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsext.vf4",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function sext(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nlet n = vs2[i] & ((1n << rs1) - 1n);\nlet sign = (n & (1n << (rs1 - 1n)));\nn = (n ^ sign) - sign;\nvd[i] = n;\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, Math.floor(checkSEW()/4), vd, vecIntOperationWrapperFactory(sext));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsext.vf8",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 v0.t",
      "signature": "vsext.vf8,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vsext.vf8 vd vs2 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsext.vf8",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function sext(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nlet n = vs2[i] & ((1n << rs1) - 1n);\nlet sign = (n & (1n << (rs1 - 1n)));\nn = (n ^ sign) - sign;\nvd[i] = n;\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, Math.floor(checkSEW()/8), vd, vecIntOperationWrapperFactory(sext));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsext.vf2",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2",
      "signature": "vsext.vf2,VEC-Reg,VEC-Reg",
      "signatureRaw": "vsext.vf2 vd vs2",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsext.vf2",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "function sext(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nlet n = vs2[i] & ((1n << rs1) - 1n);\nlet sign = (n & (1n << (rs1 - 1n)));\nn = (n ^ sign) - sign;\nvd[i] = n;\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, Math.floor(checkSEW()/2), sext);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsext.vf4",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2",
      "signature": "vsext.vf4,VEC-Reg,VEC-Reg",
      "signatureRaw": "vsext.vf4 vd vs2",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsext.vf4",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "function sext(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nlet n = vs2[i] & ((1n << rs1) - 1n);\nlet sign = (n & (1n << (rs1 - 1n)));\nn = (n ^ sign) - sign;\nvd[i] = n;\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, Math.floor(checkSEW()/4), sext);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsext.vf8",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2",
      "signature": "vsext.vf8,VEC-Reg,VEC-Reg",
      "signatureRaw": "vsext.vf8 vd vs2",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsext.vf8",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        }
      ],
      "definition": "function sext(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nlet n = vs2[i] & ((1n << rs1) - 1n);\nlet sign = (n & (1n << (rs1 - 1n)));\nn = (n ^ sign) - sign;\nvd[i] = n;\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, Math.floor(checkSEW()/8), sext);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vand.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vand.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vand.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vand.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function and(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = vs1[i] & vs2[i]\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, vs1, vd, and);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vand.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vand.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vand.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vand.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function and(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = vs1[i] & vs2[i]\n}\nreturn vd;\n}\nvd = and(vd, vs2, vs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vand.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vand.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vand.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vand.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function and(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 & vs2[i]\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, rs1, vd, vecIntOperationWrapperFactory(and));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vand.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vand.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vand.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vand.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function and(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 & vs2[i]\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, rs1, and);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vand.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vand.vi,VEC-Reg,VEC-Reg,inm-signed,v0.t",
      "signatureRaw": "vand.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vand.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function and(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 & vs2[i]\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, inm, vd, vecIntOperationWrapperFactory(and));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vand.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vand.vi,VEC-Reg,VEC-Reg,inm-signed",
      "signatureRaw": "vand.vi vd vs2 inm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vand.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function and(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 & vs2[i]\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, inm, and);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vor.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vor.vi,VEC-Reg,VEC-Reg,inm-signed,v0.t",
      "signatureRaw": "vor.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vor.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function or(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 | vs2[i];\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, inm, vd, vecIntOperationWrapperFactory(or));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vor.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vor.vi,VEC-Reg,VEC-Reg,inm-signed",
      "signatureRaw": "vor.vi vd vs2 inm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vor.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function or(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 | vs2[i];\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, inm, or);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vor.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vor.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vor.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vor.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function or(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 | vs2[i];\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, rs1, vd, vecIntOperationWrapperFactory(or));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vor.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vor.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vor.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vor.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function or(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 | vs2[i];\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, rs1, or);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vor.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vor.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vor.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vor.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function or(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = vs1[i] | vs2[i];\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, vs1, vd, or);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vor.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vor.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vor.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vor.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function or(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = vs1[i] | vs2[i];\n}\nreturn vd;\n}\nvd = or(vd, vs2, vs1)",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vxor.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vxor.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vxor.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vxor.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function xor(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = vs1[i] ^ vs2[i];\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, vs1, vd, xor);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vxor.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vxor.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vxor.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vxor.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function xor(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = vs1[i] ^ vs2[i];\n}\nreturn vd;\n}\nvd = xor(vd, vs2, vs1)",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vxor.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vxor.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vxor.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vxor.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function xor(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 ^ vs2[i];\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, rs1, vd, vecIntOperationWrapperFactory(xor));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vxor.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vxor.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vxor.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vxor.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function xor(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 ^ vs2[i];\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, rs1, xor);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vxor.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vxor.vi,VEC-Reg,VEC-Reg,inm-signed,v0.t",
      "signatureRaw": "vxor.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vxor.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function xor(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 ^ vs2[i];\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, inm, vd, vecIntOperationWrapperFactory(xor));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vxor.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vxor.vi,VEC-Reg,VEC-Reg,inm-signed",
      "signatureRaw": "vxor.vi vd vs2 inm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vxor.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function xor(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = rs1 ^ vs2[i];\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, inm, xor);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsll.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vsll.vi,VEC-Reg,VEC-Reg,inm-unsigned,v0.t",
      "signatureRaw": "vsll.vi vd vs2 uinm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsll.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "uinm",
          "type": "inm-unsigned",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function sll(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = vs2[i] << rs1;\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, uinm, vd, vecIntOperationWrapperFactory(sll));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsll.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vsll.vi,VEC-Reg,VEC-Reg,inm-unsigned",
      "signatureRaw": "vsll.vi vd vs2 uinm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsll.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "uinm",
          "type": "inm-unsigned",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function sll(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = vs2[i] << rs1;\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, uinm, sll);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsll.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vsll.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vsll.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsll.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function sll(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = vs2[i] << rs1;\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, rs1, vd, vecIntOperationWrapperFactory(sll));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsll.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vsll.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vsll.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsll.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function sll(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = vs2[i] << rs1;\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, rs1, sll);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsll.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vsll.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vsll.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsll.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function sll(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = vs2[i] << vs1[i];\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, vs1, vd, sll);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsll.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vsll.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vsll.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsll.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function sll(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = vs2[i] << vs1[i];\n}\nreturn vd;\n}\nvd = sll(vd, vs2, vs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsrl.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vsrl.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vsrl.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsrl.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function srl(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = capi_LogicalRightShift(vs2[i], vs1[i]);\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, vs1, vd, srl);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsrl.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vsrl.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vsrl.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsrl.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function srl(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = capi_LogicalRightShift(vs2[i], vs1[i]);\n}\nreturn vd;\n}\nvd = srl(vd, vs2, vs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsrl.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vsrl.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vsrl.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsrl.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function srl(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = capi_LogicalRightShift(vs2[i], rs1);\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, rs1, vd, vecIntOperationWrapperFactory(srl));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsrl.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vsrl.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vsrl.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsrl.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function srl(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = capi_LogicalRightShift(vs2[i], rs1);\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, rs1, srl);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsrl.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vsrl.vi,VEC-Reg,VEC-Reg,inm-unsigned,v0.t",
      "signatureRaw": "vsrl.vi vd vs2 uinm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsrl.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "uinm",
          "type": "inm-unsigned",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function srl(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = capi_LogicalRightShift(vs2[i], rs1);\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, uinm, vd, vecIntOperationWrapperFactory(srl));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsrl.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vsrl.vi,VEC-Reg,VEC-Reg,inm-unsigned",
      "signatureRaw": "vsrl.vi vd vs2 uinm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsrl.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "uinm",
          "type": "inm-unsigned",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function srl(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = capi_LogicalRightShift(vs2[i], rs1);\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, uinm, srl);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsra.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vsra.vi,VEC-Reg,VEC-Reg,inm-unsigned,v0.t",
      "signatureRaw": "vsra.vi vd vs2 uinm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsra.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "uinm",
          "type": "inm-unsigned",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function sra(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = capi_ArithRightShift(vs2[i], rs1);\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, uinm, vd, vecIntOperationWrapperFactory(sra));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsra.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vsra.vi,VEC-Reg,VEC-Reg,inm-unsigned",
      "signatureRaw": "vsra.vi vd vs2 uinm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsra.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "uinm",
          "type": "inm-unsigned",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function sra(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = capi_ArithRightShift(vs2[i], rs1);\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, uinm, sra);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsra.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vsra.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vsra.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsra.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function sra(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = capi_ArithRightShift(vs2[i], rs1);\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, rs1, vd, vecIntOperationWrapperFactory(sra));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsra.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vsra.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vsra.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsra.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function sra(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = capi_ArithRightShift(vs2[i], rs1);\n}\nreturn vd;\n}\nvd = vecIntOperation(vd, vs2, rs1, sra);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsra.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vsra.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vsra.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsra.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "function sra(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = capi_ArithRightShift(vs2[i], vs1[i]);\n}\nreturn vd;\n}\nvd = maskedOperation(checkVl(), vs2, vs1, vd, sra);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vsra.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vsra.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vsra.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vsra.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "function sra(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = capi_ArithRightShift(vs2[i], vs1[i]);\n}\nreturn vd;\n}\nvd = sra(vd, vs2, vs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmseq.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmseq.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmseq.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmseq.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] == vs1[i]) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmseq.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmseq.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmseq.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmseq.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfor (let i = 0; i < vl; ++i) {\nmask_val[i] = (vs2[i] == vs1[i]) ? 1 : 0;\n}\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsne.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsne.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmsne.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsne.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] != vs1[i]) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsne.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsne.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmsne.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsne.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfor (let i = 0; i < vl; ++i) {\nmask_val[i] = (vs2[i] != vs1[i]) ? 1 : 0;\n}\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmslt.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmslt.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmslt.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmslt.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] < vs1[i]) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmslt.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmslt.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmslt.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmslt.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfor (let i = 0; i < vl; ++i) {\nmask_val[i] = (vs2[i] < vs1[i]) ? 1 : 0;\n}\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsle.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsle.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmsle.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsle.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] <= vs1[i]) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsle.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsle.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmsle.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsle.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfor (let i = 0; i < vl; ++i) {\nmask_val[i] = (vs2[i] <= vs1[i]) ? 1 : 0;\n}\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgt.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsgt.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmsgt.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgt.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] > vs1[i]) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgt.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsgt.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmsgt.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgt.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfor (let i = 0; i < vl; ++i) {\nmask_val[i] = (vs2[i] > vs1[i]) ? 1 : 0;\n}\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmseq.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmseq.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmseq.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmseq.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] == vs1[i]) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmseq.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmseq.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmseq.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmseq.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] == rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsne.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsne.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmsne.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsne.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] != vs1[i]) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsne.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsne.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmsne.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsne.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] != rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmslt.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmslt.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmslt.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmslt.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] < vs1[i]) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmslt.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmslt.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmslt.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmslt.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] < rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsle.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsle.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmsle.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsle.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] <= vs1[i]) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsle.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsle.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmsle.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsle.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] <= rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgt.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsgt.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmsgt.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgt.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] > vs1[i]) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgt.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsgt.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmsgt.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgt.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] > rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmseq.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmseq.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vmseq.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmseq.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] == rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, rs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmseq.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmseq.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vmseq.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmseq.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] == rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsne.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsne.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vmsne.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsne.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] != rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, rs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsne.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsne.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vmsne.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsne.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] != rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmslt.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmslt.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vmslt.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmslt.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] < rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, rs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmslt.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmslt.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vmslt.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmslt.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] < rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsle.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsle.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vmsle.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsle.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] <= rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, rs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsle.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsle.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vmsle.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsle.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] <= rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgt.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsgt.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vmsgt.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgt.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] > rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, rs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgt.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsgt.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vmsgt.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgt.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] > rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmseq.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmseq.vi,VEC-Reg,VEC-Reg,inm-signed,v0.t",
      "signatureRaw": "vmseq.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmseq.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] == rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, inm, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmseq.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmseq.vi,VEC-Reg,VEC-Reg,inm-signed",
      "signatureRaw": "vmseq.vi vd vs2 inm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmseq.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] == rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, inm, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsne.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsne.vi,VEC-Reg,VEC-Reg,inm-signed,v0.t",
      "signatureRaw": "vmsne.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsne.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] != rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, inm, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsne.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsne.vi,VEC-Reg,VEC-Reg,inm-signed",
      "signatureRaw": "vmsne.vi vd vs2 inm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsne.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] != rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, inm, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmslt.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmslt.vi,VEC-Reg,VEC-Reg,inm-signed,v0.t",
      "signatureRaw": "vmslt.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmslt.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] < rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, inm, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmslt.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmslt.vi,VEC-Reg,VEC-Reg,inm-signed",
      "signatureRaw": "vmslt.vi vd vs2 inm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmslt.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] < rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, inm, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsle.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsle.vi,VEC-Reg,VEC-Reg,inm-signed,v0.t",
      "signatureRaw": "vmsle.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsle.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] <= rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, inm, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsle.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsle.vi,VEC-Reg,VEC-Reg,inm-signed",
      "signatureRaw": "vmsle.vi vd vs2 inm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsle.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] <= rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, inm, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgt.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsgt.vi,VEC-Reg,VEC-Reg,inm-signed,v0.t",
      "signatureRaw": "vmsgt.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgt.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] > rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, inm, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgt.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsgt.vi,VEC-Reg,VEC-Reg,inm-signed",
      "signatureRaw": "vmsgt.vi vd vs2 inm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgt.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (vs2[i] > rs1) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, inm, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsltu.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsltu.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmsltu.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsltu.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) < capi_LogicalRightShift(vs1[i], 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsltu.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsltu.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmsltu.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsltu.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) < capi_LogicalRightShift(vs1[i], 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = comparison(vd, vs2, vs1);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsleu.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsleu.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmsleu.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsleu.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) <= capi_LogicalRightShift(vs1[i], 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsleu.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsleu.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmsleu.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsleu.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) <= capi_LogicalRightShift(vs1[i], 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = comparison(vd, vs2, vs1);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgtu.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsgtu.vv,VEC-Reg,VEC-Reg,VEC-Reg,v0.t",
      "signatureRaw": "vmsgtu.vv vd vs2 vs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgtu.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) > capi_LogicalRightShift(vs1[i], 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, vs1, mask_val, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgtu.vv",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsgtu.vv,VEC-Reg,VEC-Reg,VEC-Reg",
      "signatureRaw": "vmsgtu.vv vd vs2 vs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgtu.vv",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "vs1",
          "type": "VEC-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, vs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) > capi_LogicalRightShift(vs1[i], 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = comparison(vd, vs2, vs1);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsltu.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsltu.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vmsltu.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsltu.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) < capi_LogicalRightShift(rs1, 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, rs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsltu.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsltu.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vmsltu.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsltu.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) < capi_LogicalRightShift(rs1, 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsleu.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsleu.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vmsleu.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsleu.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) <= capi_LogicalRightShift(rs1, 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, rs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsleu.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsleu.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vmsleu.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsleu.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) <= capi_LogicalRightShift(rs1, 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgtu.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsgtu.vx,VEC-Reg,VEC-Reg,INT-Reg,v0.t",
      "signatureRaw": "vmsgtu.vx vd vs2 rs1 v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgtu.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) > capi_LogicalRightShift(rs1, 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, rs1, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgtu.vx",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsgtu.vx,VEC-Reg,VEC-Reg,INT-Reg",
      "signatureRaw": "vmsgtu.vx vd vs2 rs1",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgtu.vx",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) > capi_LogicalRightShift(rs1, 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, rs1, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsltu.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsltu.vi,VEC-Reg,VEC-Reg,inm-unsigned,v0.t",
      "signatureRaw": "vmsltu.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsltu.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) < capi_LogicalRightShift(rs1, 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, inm, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsltu.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsltu.vi,VEC-Reg,VEC-Reg,inm-unsigned",
      "signatureRaw": "vmsltu.vi vd vs2 inm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsltu.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) < capi_LogicalRightShift(rs1, 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, inm, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsleu.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsleu.vi,VEC-Reg,VEC-Reg,inm-unsigned,v0.t",
      "signatureRaw": "vmsleu.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsleu.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) <= capi_LogicalRightShift(rs1, 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, inm, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsleu.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsleu.vi,VEC-Reg,VEC-Reg,inm-unsigned",
      "signatureRaw": "vmsleu.vi vd vs2 inm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsleu.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) <= capi_LogicalRightShift(rs1, 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, inm, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgtu.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3 v0.t",
      "signature": "vmsgtu.vi,VEC-Reg,VEC-Reg,inm-unsigned,v0.t",
      "signatureRaw": "vmsgtu.vi vd vs2 inm v0.t",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgtu.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "vm",
          "type": "VEC-Reg",
          "startbit": 25,
          "stopbit": 25
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) > capi_LogicalRightShift(rs1, 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = maskedOperation(vl, vs2, inm, mask_val, vecIntOperationWrapperFactory(comparison));\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "vmsgtu.vi",
      "type": "Vector arithmetic",
      "signature_definition": "F0 F1 F2 F3",
      "signature": "vmsgtu.vi,VEC-Reg,VEC-Reg,inm-unsigned",
      "signatureRaw": "vmsgtu.vi vd vs2 inm",
      "co": "1010111",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "vmsgtu.vi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "vd",
          "type": "VEC-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "vs2",
          "type": "VEC-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "let mask_val = extractMaskByName(vd_name);\nfunction comparison(vd, vs2, rs1) {\nfor (let i = 0; i < vl; ++i) {\nvd[i] = (capi_LogicalRightShift(vs2[i], 0) > capi_LogicalRightShift(rs1, 0)) ? 1 : 0;\n}\nreturn vd;\n}\nmask_val = vecIntOperation(mask_val, vs2, inm, comparison);\nwriteMaskByName(vd_name, mask_val);",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "add",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "add,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "add rd rs1 rs2",
      "co": "0110011",
      "cop": "0000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "add",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000000"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        }
      ],
      "definition": "rd = rs2 + rs1",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "addi",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "addi,INT-Reg,INT-Reg,inm-signed",
      "signatureRaw": "addi rd rs1 inm",
      "co": "0010011",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "addi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": "14",
          "stopbit": "12",
          "valueField": "000"
        }
      ],
      "definition": "rd = rs1 + inm;",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "and",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "and,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "and rd rs1 rs2",
      "co": "0110011",
      "cop": "0000000111",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "and",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000000"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "111"
        }
      ],
      "definition": "rd = rs1 & rs2;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "andi",
      "type": "Logic",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "andi,INT-Reg,INT-Reg,inm-signed",
      "signatureRaw": "andi rd rs1 inm",
      "co": "0010011",
      "cop": "111",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "andi",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "111"
        }
      ],
      "definition": "rd = rs1 & capi_int2uint(inm);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "auipc",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F2 F1",
      "signature": "auipc,INT-Reg,offset_words",
      "signatureRaw": "auipc rd inm",
      "co": "0010111",
      "cop": "",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "auipc",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "offset_words",
          "startbit": 31,
          "stopbit": 12
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = PC + (inm << 12);",
      "separated": [
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "beq",
      "type": "Conditional bifurcation",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "beq,INT-Reg,INT-Reg,offset_words",
      "signatureRaw": "beq rs1 rs2 inm",
      "co": "1100011",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "beq",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        },
        {
          "name": "inm",
          "type": "offset_words",
          "startbit": [
            31,
            11
          ],
          "stopbit": [
            25,
            7
          ]
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        }
      ],
      "definition": "if (rs1 === rs2)\n PC = PC + ((inm << 16) >> 14); ",
      "separated": [
        false,
        false,
        true,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "bge",
      "type": "Conditional bifurcation",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "bge,INT-Reg,INT-Reg,offset_words",
      "signatureRaw": "bge rs1 rs2 inm",
      "co": "1100011",
      "cop": "101",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "bge",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "offset_words",
          "startbit": [
            31,
            11
          ],
          "stopbit": [
            25,
            7
          ]
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "101"
        }
      ],
      "definition": "if (capi_uint2int(rs1) >= capi_uint2int(rs2))\n PC = PC + ((inm << 16) >> 14);",
      "separated": [
        false,
        true,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "bgeu",
      "type": "Conditional bifurcation",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "bgeu,INT-Reg,INT-Reg,offset_words",
      "signatureRaw": "bgeu rs1 rs2 inm",
      "co": "1100011",
      "cop": "111",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "bgeu",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "offset_words",
          "startbit": [
            31,
            11
          ],
          "stopbit": [
            25,
            7
          ]
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "111"
        }
      ],
      "definition": "if (capi_int2uint(rs1) > capi_int2uint(rs2))\n PC = PC + ((inm << 16) >> 14);",
      "separated": [
        false,
        true,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "blt",
      "type": "Conditional bifurcation",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "blt,INT-Reg,INT-Reg,offset_words",
      "signatureRaw": "blt rs1 rs2 inm",
      "co": "1100011",
      "cop": "100",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "blt",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "offset_words",
          "startbit": [
            31,
            11
          ],
          "stopbit": [
            25,
            7
          ]
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "100"
        }
      ],
      "definition": "if (capi_uint2int(rs1) < capi_uint2int(rs2))\n PC = PC + ((inm << 16) >> 14);",
      "separated": [
        false,
        true,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "bltu",
      "type": "Conditional bifurcation",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "bltu,INT-Reg,INT-Reg,offset_words",
      "signatureRaw": "bltu rs1 rs2 inm",
      "co": "1100011",
      "cop": "110",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "bltu",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "offset_words",
          "startbit": [
            31,
            11
          ],
          "stopbit": [
            25,
            7
          ]
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "110"
        }
      ],
      "definition": "if (capi_int2uint(rs1) < capi_int2uint(rs2))\n PC = PC + ((inm << 16) >> 14);",
      "separated": [
        false,
        true,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "bne",
      "type": "Conditional bifurcation",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "bne,INT-Reg,INT-Reg,offset_words",
      "signatureRaw": "bne rs1 rs2 inm",
      "co": "1100011",
      "cop": "001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "bne",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "offset_words",
          "startbit": [
            31,
            11
          ],
          "stopbit": [
            25,
            7
          ]
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        }
      ],
      "definition": "if (rs1 !== rs2)\n PC = PC + ((inm << 16) >> 14);",
      "separated": [
        false,
        true,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "div",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "div,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "div rd rs1 rs2",
      "co": "0110011",
      "cop": "0000001100",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "div",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000001"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "100"
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "if (rs2 != 0)\n { rd = (rs1 >> 0) / (rs2 >> 0); }\n else { capi_raise('Division by zero not allowed'); }",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "ecall",
      "type": "Syscall",
      "co": "000000",
      "cop": "001100",
      "nwords": 1,
      "clk_cycles": 1,
      "signature_definition": "F0",
      "signature": "ecall",
      "signatureRaw": "ecall",
      "fields": [
        {
          "name": "ecall",
          "type": "co",
          "startbit": 31,
          "stopbit": 26
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 5,
          "stopbit": 0,
          "valueField": "001100"
        }
      ],
      "definition": "switch(a7){\ncase 1:\ncapi_print_int('a0');\nbreak;\ncase 2:\ncapi_print_float('fa0');\nbreak;\ncase 3:\ncapi_print_double('fa0');\nbreak;\ncase 4:\ncapi_print_string('a0');\nbreak;\ncase 5:\ncapi_read_int('a0');\nbreak;\ncase 6:\ncapi_read_float('fa0');\nbreak;\ncase 7:\ncapi_read_double('fa0');\nbreak;\ncase 8:\ncapi_read_string('a0', 'a1');\nbreak;\ncase 9:\ncapi_sbrk('a0', 'a0');\nbreak;\ncase 10:\ncapi_exit();\nbreak;\ncase 11:\ncapi_print_char('a0');\nbreak;\ncase 12:\ncapi_read_char('a0');\nbreak;\n}",
      "help": ""
    },
    {
      "name": "fadd.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "FADD.D,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "FADD.D rd rs1 rs2",
      "co": "1010011",
      "cop": "0000001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "FADD.D",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000001"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs1 + rs2;",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fadd.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "fadd.s,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fadd.s rd rs1 rs2",
      "co": "1010011",
      "cop": "0000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fadd.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000000"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs2 + rs1;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fclass.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "fclass.d,INT-Reg,DFP-Reg,cop",
      "signatureRaw": "fclass.d rd rs1 cop2",
      "co": "1010011",
      "cop": "111000100000001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fclass.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1110001"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop3",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "let a = capi_float2bin(rs1);\nrd=capi_check_ieee(parseInt(a[0]), parseInt(a.slice(1,12), 2), parseInt(a.slice(13), 2));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fclass.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3 F4",
      "signature": "fclass.s,INT-Reg,SFP-Reg,INT-Reg",
      "signatureRaw": "fclass.s rd rs1 rd",
      "co": "1010011",
      "cop": "111000000000001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "FCLASS.S",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1110000"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop3",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        }
      ],
      "definition": "let a = capi_float2bin(rs1);\nrd=capi_check_ieee(parseInt(a[0]), parseInt(a.slice(1,9), 2), parseInt(a.slice(10), 2));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fcvt.d.s",
      "type": "Transfer between registers",
      "signature_definition": "F0 F4 F3",
      "signature": "fcvt.d.s,DFP-Reg,SFP-Reg",
      "signatureRaw": "fcvt.d.s rd rs1",
      "co": "1010011",
      "cop": "010000100000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fcvt.d.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0100001"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs1;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fcvt.d.w",
      "type": "Transfer between registers",
      "signature_definition": "F0 F4 F3",
      "signature": "fcvt.d.w,DFP-Reg,INT-Reg",
      "signatureRaw": "fcvt.d.w rd rs1",
      "co": "1010011",
      "cop": "110100100000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fcvt.d.w",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1101001"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = capi_uint2int(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fcvt.d.wu",
      "type": "Transfer between registers",
      "signature_definition": "F0 F4 F3",
      "signature": "fcvt.d.wu,DFP-Reg,INT-Reg",
      "signatureRaw": "fcvt.d.wu rd rs1",
      "co": "1010011",
      "cop": "110100100001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fcvt.d.wu",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1101001"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00001"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = capi_int2uint(parseFloat(rs1));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fcvt.s.d",
      "type": "Transfer between registers",
      "signature_definition": "F0 F4 F3",
      "signature": "fcvt.s.d,SFP-Reg,DFP-Reg",
      "signatureRaw": "fcvt.s.d rd rs1",
      "co": "1010011",
      "cop": "010000000001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fcvt.s.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0100000"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00001"
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs1;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fcvt.s.w",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3",
      "signature": "fcvt.s.w,SFP-Reg,INT-Reg",
      "signatureRaw": "fcvt.s.w rd rs1",
      "co": "1010011",
      "cop": "110100000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fcvt.s.w",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "valueField": "1101000",
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = capi_uint2int(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fcvt.s.wu",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3",
      "signature": "fcvt.s.wu,SFP-Reg,INT-Reg",
      "signatureRaw": "fcvt.s.wu rd rs1",
      "co": "1010011",
      "cop": "110100000001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fcvt.s.wu",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "valueField": "1101000",
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00001"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = capi_int2uint(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fcvt.w.d",
      "type": "Transfer between registers",
      "signature_definition": "F0 F4 F3",
      "signature": "fcvt.w.d,INT-Reg,DFP-Reg",
      "signatureRaw": "fcvt.w.d rd rs1",
      "co": "1010011",
      "cop": "110000100000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fcvt.w.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1100001"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = parseInt(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fcvt.w.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3",
      "signature": "fcvt.w.s,INT-Reg,SFP-Reg",
      "signatureRaw": "fcvt.w.s rd rs1",
      "co": "1010011",
      "cop": "110000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fcvt.w.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1100000"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = parseInt(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fcvt.wu.d",
      "type": "Transfer between registers",
      "signature_definition": "F0 F4 F3",
      "signature": "fcvt.wu.d,INT-Reg,DFP-Reg",
      "signatureRaw": "fcvt.wu.d rd rs1",
      "co": "1010011",
      "cop": "110000100001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fcvt.wu.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1100001"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00001"
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = capi_int2uint(parseInt(rs1));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fcvt.wu.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3",
      "signature": "fcvt.wu.s,INT-Reg,SFP-Reg",
      "signatureRaw": "fcvt.wu.s rd rs1",
      "co": "1010011",
      "cop": "110000000001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fcvt.wu.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1100000"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00001"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = capi_int2uint(parseInt(rs1));",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fdiv.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "fdiv.d,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "fdiv.d rd rs1 rs2",
      "co": "1010011",
      "cop": "0001101",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fdiv.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0001101"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "if (rs2 != 0)\n { rd = rs1 / rs2; }\n else { capi_raise('Division by zero not allowed'); }",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fdiv.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "fdiv.s,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fdiv.s rd rs1 rs2",
      "co": "1010011",
      "cop": "0001100",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fdiv.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0001100"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "if (rs2 != 0)\n { rd = rs1 / rs2; }\n else { capi_raise('Division by zero not allowed'); }",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "feq.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "feq.d,INT-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "feq.d rd rs1 rs2",
      "co": "1010011",
      "cop": "1010001010",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "feq.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1010001"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = (rs1 == rs2) ? 1 : 0;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "feq.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "feq.s,INT-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "feq.s rd rs1 rs2",
      "co": "1010011",
      "cop": "1010000010",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "feq.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1010000"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "rd = (rs1 === rs2) ? 1 : 0;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fld",
      "type": "Memory access",
      "signature_definition": "F0 F4 F1 (F2)",
      "signature": "fld,DFP-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "fld rd inm (rs1)",
      "co": "0000111",
      "cop": "011",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fld",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "011"
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": " var isnotalign = capi_bad_align(rs1+inm, 'd');\n if (isnotalign) { capi_raise('The memory must be align'); }\n var val1 = capi_mem_read(rs1+inm, 'w', rd_name);\n var val2 = capi_mem_read(rs1+inm+4, 'w', rd_name);\n var buf = new ArrayBuffer(8);\n var arr = (new Uint32Array(buf));\n arr[1] = val1;\n arr[0] = val2;\n rd = (new Float64Array(buf))[0];",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fle.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "fle.d,INT-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "fle.d rd rs1 rs2",
      "co": "1010011",
      "cop": "1010001000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fle.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1010001"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = (rs1 <= rs2) ? 1 : 0;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fle.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "fle.s,INT-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fle.s rd rs1 rs2",
      "co": "1010011",
      "cop": "1010000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fle.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1010000"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        }
      ],
      "definition": "rd = (rs1 <= rs2) ? 1 : 0;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "flt.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "flt.d,INT-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "flt.d rd rs1 rs2",
      "co": "1010011",
      "cop": "1010001001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "flt.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1010001"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = (rs1 < rs2) ? 1 : 0;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "flt.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "flt.s,INT-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "flt.s rd rs1 rs2",
      "co": "1010011",
      "cop": "1010000001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "flt.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1010000"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        }
      ],
      "definition": "rd = (rs1 < rs2) ? 1 : 0;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "flw",
      "type": "Memory access",
      "signature_definition": "F0 F4 F1 (F2)",
      "signature": "flw,SFP-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "flw rd inm (rs2)",
      "co": "0000111",
      "cop": "010",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "flw",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = capi_mem_read(rs2+inm, 'w', rd_name);\n rd = capi_uint2float32(rd);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fmadd.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F4 F3 F1",
      "signature": "FMADD.D,DFP-Reg,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "FMADD.D rd rs1 rs2 rs3",
      "co": "1000011",
      "cop": "01",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "FMADD.D",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rs3",
          "type": "DFP-Reg",
          "startbit": 31,
          "stopbit": 27
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 26,
          "stopbit": 25,
          "valueField": "01"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs1 * rs2 + rs3;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fmadd.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F4 F3 F1",
      "signature": "fmadd.s,SFP-Reg,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fmadd.s rd rs1 rs2 rs3",
      "co": "1000011",
      "cop": "00",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fmadd.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rs3",
          "type": "SFP-Reg",
          "startbit": 31,
          "stopbit": 27
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 26,
          "stopbit": 25,
          "valueField": "00"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs1 * rs2 + rs3;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fmax.d",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "FMAX.D,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "FMAX.D rd rs1 rs2",
      "co": "1010011",
      "cop": "0010101001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "FMAX.D",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0010101"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = Math.max(rs1, rs2);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fmax.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "fmax.s,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fmax.s rd rs1 rs2",
      "co": "1010011",
      "cop": "0010100001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fmax.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0010100"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = Math.max(rs1, rs2);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fmin.d",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "FMIN.D,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "FMIN.D rd rs1 rs2",
      "co": "1010011",
      "cop": "0010101000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "FMIN.D",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0010101"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = Math.min(rs1, rs2);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fmin.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "fmin.s,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fmin.s rd rs1 rs2",
      "co": "1010011",
      "cop": "0010100000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fmin.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0010100"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = Math.min(rs1, rs2);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fmsub.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F4 F3 F1",
      "signature": "fmsub.d,DFP-Reg,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "fmsub.d rd rs1 rs2 rs3",
      "co": "1000111",
      "cop": "01",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fmsub.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rs3",
          "type": "DFP-Reg",
          "startbit": 31,
          "stopbit": 27
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 26,
          "stopbit": 25,
          "valueField": "01"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs1 * rs2 - rs3;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fmsub.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F4 F3 F1",
      "signature": "fmsub.s,SFP-Reg,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fmsub.s rd rs1 rs2 rs3",
      "co": "1000111",
      "cop": "00",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fmsub.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rs3",
          "type": "SFP-Reg",
          "startbit": 31,
          "stopbit": 27
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 26,
          "stopbit": 25,
          "valueField": "00"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs1 * rs2 - rs3;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fmul.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "fmul.d,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "fmul.d rd rs1 rs2",
      "co": "1010011",
      "cop": "0001001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fmul.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0001001"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs1 * rs2;",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fmul.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "fmul.s,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fmul.s rd rs1 rs2",
      "co": "1010011",
      "cop": "0001000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fmul.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0001000"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs2 * rs1;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fmv.w.x",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3",
      "signature": "fmv.w.x,SFP-Reg,INT-Reg",
      "signatureRaw": "fmv.w.x rd rs1",
      "co": "1010011",
      "cop": "111100000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fmv.w.x",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "valueField": "1111000",
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = capi_uint2float32(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fmv.x.w",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3",
      "signature": "fmv.x.w,INT-Reg,SFP-Reg",
      "signatureRaw": "fmv.x.w rd rs1",
      "co": "1010011",
      "cop": "111000000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fmv.x.w",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "1110000"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = capi_float322uint(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fnmadd.d",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F5 F4 F3 F1",
      "signature": "fnmadd.d,DFP-Reg,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "fnmadd.d rd rs1 rs2 rs3",
      "co": "1001111",
      "cop": "01",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fnmadd.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rs3",
          "type": "DFP-Reg",
          "startbit": 31,
          "stopbit": 27
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 26,
          "stopbit": 25,
          "valueField": "01"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = -rs1 * rs2 - rs3;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fnmadd.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F4 F3 F1",
      "signature": "fnmadd.s,SFP-Reg,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fnmadd.s rd rs1 rs2 rs3",
      "co": "1001111",
      "cop": "00",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fnmadd.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rs3",
          "type": "SFP-Reg",
          "startbit": 31,
          "stopbit": 27
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 26,
          "stopbit": 25,
          "valueField": "00"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = -rs1 * rs2 - rs3;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fnmsub.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F4 F3 F1",
      "signature": "fnmsub.d,DFP-Reg,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "fnmsub.d rd rs1 rs2 rs3",
      "co": "1001011",
      "cop": "01",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fnmsub.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rs3",
          "type": "DFP-Reg",
          "startbit": 31,
          "stopbit": 27
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 26,
          "stopbit": 25,
          "valueField": "01"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = -rs1 * rs2 + rs3;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fnmsub.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F4 F3 F1",
      "signature": "fnmsub.s,SFP-Reg,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fnmsub.s rd rs1 rs2 rs3",
      "co": "1001011",
      "cop": "00",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fnmsub.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rs3",
          "type": "SFP-Reg",
          "startbit": 31,
          "stopbit": 27
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 26,
          "stopbit": 25,
          "valueField": "00"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = -rs1 * rs2 + rs3;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fsd",
      "type": "Memory access",
      "signature_definition": "F0 F2 F3 (F1)",
      "signature": "fsd,DFP-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "fsd ft off (base)",
      "co": "0100111",
      "cop": "011",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fsd",
          "type": "co",
          "startbit": 31,
          "stopbit": 26
        },
        {
          "name": "base",
          "type": "INT-Reg",
          "startbit": 25,
          "stopbit": 21
        },
        {
          "name": "ft",
          "type": "DFP-Reg",
          "startbit": 20,
          "stopbit": 16
        },
        {
          "name": "off",
          "type": "inm-unsigned",
          "startbit": 15,
          "stopbit": 0
        }
      ],
      "definition": "var val = capi_split_double(ft, 0);\n capi_mem_write(base+off, val, 'w', ft_name);\n val = capi_split_double(ft, 1);\n capi_mem_write(base+off+4, val, 'w', ft_name);",
      "separated": [
        false,
        true,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fsgnj.d",
      "type": "Transfer between registers",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "fsgnj.d,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "fsgnj.d rd rs1 rs2",
      "co": "1010011",
      "cop": "0010001000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fsgnj.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0010001"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = (rs2 > 0) ? Math.abs(rs1) : -Math.abs(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fsgnj.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "fsgnj.s,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fsgnj.s rd rs1 rs2",
      "co": "1010011",
      "cop": "0010000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fsgnj.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0010000"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = (rs2 >= 0) ? Math.abs(rs1) : -Math.abs(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fsgnjn.d",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "fsgnjn.d,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "fsgnjn.d rd rs1 rs2",
      "co": "1010011",
      "cop": "0010001001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fsgnjn.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0010001"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = (rs2 > 0) ? -Math.abs(rs1) : +Math.abs(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fsgnjn.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "fsgnjn.s,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fsgnjn.s rd rs1 rs2",
      "co": "1010011",
      "cop": "0010000001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fsgnjn.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0010000"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = (rs2 <= 0) ? Math.abs(rs1) : -Math.abs(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fsgnjx.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "fsgnjx.d,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "fsgnjx.d rd rs1 rs2",
      "co": "1010011",
      "cop": "0010001010",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fsgnjx.d",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0010001"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "let a = rs1<0; let b = rs2<0;\nrd = (a^b) ? -Math.abs(rs1) : Math.abs(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fsgnjx.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "fsgnjx.s,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fsgnjx.s rd rs1 rs2",
      "co": "1010011",
      "cop": "0010000010",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fsgnjx.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0010000"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "let a = rs1<0; let b = rs2<0;\nrd = (a^b) ? -Math.abs(rs1) : Math.abs(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fsqrt.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3",
      "signature": "FSQRT.D,DFP-Reg,DFP-Reg",
      "signatureRaw": "FSQRT.D rd rs1",
      "co": "1010011",
      "cop": "010110100000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "FSQRT.D",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0101101"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = Math.sqrt(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fsqrt.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3",
      "signature": "fsqrt.s,SFP-Reg,SFP-Reg",
      "signatureRaw": "fsqrt.s rd rs1",
      "co": "1010011",
      "cop": "010110000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fsqrt.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0101100"
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 24,
          "stopbit": 20,
          "valueField": "00000"
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = Math.sqrt(rs1);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fsub.d",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "FSUB.D,DFP-Reg,DFP-Reg,DFP-Reg",
      "signatureRaw": "FSUB.D rd rs1 rs2",
      "co": "1010011",
      "cop": "0000101",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "FSUB.D",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000101"
        },
        {
          "name": "rs2",
          "type": "DFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "DFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "DFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs1 - rs2;",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fsub.s",
      "type": "Arithmetic floating point",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "fsub.s,SFP-Reg,SFP-Reg,SFP-Reg",
      "signatureRaw": "fsub.s rd rs1 rs2",
      "co": "1010011",
      "cop": "0001100",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fsub.s",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0001100"
        },
        {
          "name": "rs2",
          "type": "SFP-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "SFP-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs1 - rs2;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "fsw",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2)",
      "signature": "fsw,SFP-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "fsw rs1 inm (rs2)",
      "co": "0100111",
      "cop": "010",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "fsw",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": [
            31,
            11
          ],
          "stopbit": [
            25,
            7
          ]
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "SFP-Reg",
          "startbit": 19,
          "stopbit": 15,
          "valueField": "010"
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "var val1 = capi_float322uint(rs1);\n capi_mem_write(rs2+inm, val1, 'w', rs1_name);",
      "separated": [
        false,
        true,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "jal",
      "type": "Unconditional bifurcation",
      "signature_definition": "F0 F2 F1",
      "signature": "jal,INT-Reg,inm-unsigned",
      "signatureRaw": "jal rd inm",
      "co": "1101111",
      "cop": "",
      "help": "",
      "properties": [
        "enter_subrutine"
      ],
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "jal",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 31,
          "stopbit": 12
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 12,
          "stopbit": 7
        }
      ],
      "definition": "rd = PC;\n PC = inm;\n capi_callconv_begin(inm); capi_drawstack_begin(inm);",
      "separated": [
        false,
        false,
        false
      ]
    },
    {
      "name": "jalr",
      "type": "Unconditional bifurcation",
      "signature_definition": "F0 F3 F1 (F2)",
      "signature": "jalr,INT-Reg,inm-signed,(INT-Reg)",
      "signatureRaw": "jalr rd inm (rs1)",
      "co": "1100111",
      "cop": "000",
      "help": "",
      "properties": [
        "exit_subrutine"
      ],
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "jalr",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        }
      ],
      "definition": "rd = PC;\n PC = (rs1+inm)&~1;\n capi_callconv_end(); capi_drawstack_end(PC);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ]
    },
    {
      "name": "lb",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2)",
      "signature": "lb,INT-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "lb rd inm (rs1)",
      "co": "0000011",
      "cop": "000",
      "nwords": "1",
      "fields": [
        {
          "name": "lb",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        }
      ],
      "definition": "rd = capi_mem_read(inm+rs1, 'b', rd_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "lbu",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2)",
      "signature": "lbu,INT-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "lbu rd inm (rs1)",
      "co": "0000011",
      "cop": "100",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "lbu",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "100"
        }
      ],
      "definition": "var addr = capi_int2uint(rs1)+inm;\n rd = capi_mem_read(addr, 'bu', rd_name);\n rd = capi_int2uint(rd);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "lh",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2)",
      "signature": "lh,INT-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "lh rd inm (rs1)",
      "co": "0000011",
      "cop": "001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "lh",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        }
      ],
      "definition": "rd = capi_mem_read(inm+rs1, 'h', rd_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "lhu",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2)",
      "signature": "lhu,INT-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "lhu rd inm (rs1)",
      "co": "0000011",
      "cop": "101",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "lhu",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "101"
        }
      ],
      "definition": "var addr = capi_int2uint(rs1)+inm;\n rd = capi_mem_read(addr, 'hu', rd_name);\n rd = capi_int2uint(rd);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "lui",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F2 F1",
      "signature": "lui,INT-Reg,inm-signed",
      "signatureRaw": "lui rd inm",
      "co": "0110111",
      "cop": "",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "lui",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 31,
          "stopbit": 12
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = inm << 12;",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "lw",
      "type": "Memory access",
      "signature_definition": "F0 F3 F1 (F2)",
      "signature": "lw,INT-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "lw rd inm (rs1)",
      "co": "0000011",
      "cop": "010",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "lw",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "var addr = capi_int2uint(rs1)+inm;\n rd = capi_mem_read(addr, 'w', rd_name);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "mul",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "mul,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "mul rd rs1 rs2",
      "co": "0110011",
      "cop": "0000001000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "mul",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000001"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = capi_uint2int(rs1) * capi_uint2int(rs2);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "mulh",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "mulh,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "mulh rd rs1 rs2",
      "co": "0110011",
      "cop": "0000001010",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "mulh",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000001"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = ((rs1 * rs2) >>> 32);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "mulhsu",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "mulhsu,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "mulhsu rd rs1 rs2",
      "co": "0110011",
      "cop": "0000001000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "mulhsu",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000001"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = ((rs1 * capi_int2uint(rs2)) >>> 32);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "mulhu",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "mulhu,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "mulhu rd rs1 rs2",
      "co": "0110011",
      "cop": "0000001011",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "mulhu",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000001"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "011"
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = ((capi_int2uint(rs1) * capi_int2uint(rs2)) >>> 32);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "or",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "or,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "or rd rs1 rs2",
      "co": "0110011",
      "cop": "0000000110",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "or",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000000"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "110"
        }
      ],
      "definition": "rd = rs1 | rs2;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "ori",
      "type": "Logic",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "ori,INT-Reg,INT-Reg,inm-signed",
      "signatureRaw": "ori rd rs1 inm",
      "co": "0010011",
      "cop": "110",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "ori",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "110"
        }
      ],
      "definition": "rd = rs1 | inm;",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "rdcycle",
      "type": "Syscall",
      "co": "1110011",
      "cop": "010",
      "nwords": 1,
      "clk_cycles": 1,
      "signature_definition": "F0 F1",
      "signature": "rdcycle,INT-Reg",
      "signatureRaw": "rdcycle rd",
      "fields": [
        {
          "name": "rdcycle",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "rd = capi_get_clk_cycles();",
      "help": ""
    },
    {
      "name": "rem",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F5 F3 F2",
      "signature": "rem,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "rem rd rs1 rs2",
      "co": "0110011",
      "cop": "0000001110",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "rem",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000001"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "110"
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        }
      ],
      "definition": "rd = rs1 % rs2;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "sb",
      "type": "Memory access",
      "signature_definition": "F0 F2 F1 (F3)",
      "signature": "sb,INT-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "sb rs2 inm (rs1)",
      "co": "0100011",
      "cop": "000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "sb",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": [
            31,
            11
          ],
          "stopbit": [
            25,
            7
          ]
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        }
      ],
      "definition": "capi_mem_write(rs1+inm, rs2, 'b', rs2_name);",
      "separated": [
        false,
        true,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "sh",
      "type": "Memory access",
      "signature_definition": "F0 F2 F1 (F3)",
      "signature": "sh,INT-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "sh rs2 inm (rs1)",
      "co": "0100011",
      "cop": "001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "sh",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-signeinm-unsigned",
          "startbit": [
            31,
            11
          ],
          "stopbit": [
            25,
            7
          ]
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        }
      ],
      "definition": "capi_mem_write(inm+rs1, rs2, 'h', rs2_name);",
      "separated": [
        false,
        true,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "sll",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "sll,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "sll rd rs1 rs2",
      "co": "0110011",
      "cop": "0000000001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "sll",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "opcode",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000000"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": "14",
          "stopbit": "12",
          "valueField": "001"
        }
      ],
      "definition": "rd = capi_int2uint(rs1 << rs2);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "slli",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F1 F3 F4",
      "signature": "slli,INT-Reg,INT-Reg,inm-unsigned",
      "signatureRaw": "slli rd rs1 shamt",
      "co": "0010011",
      "cop": "000000001",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "slli",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "001"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "shamt",
          "type": "inm-unsigned",
          "startbit": 25,
          "stopbit": 20
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 26,
          "valueField": "000000"
        }
      ],
      "definition": "if (shamt > 0) {rd = capi_int2uint(rs1 << shamt);}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "slt",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "slt,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "slt rd rs1 rs2",
      "co": "0110011",
      "cop": "0000000010",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "slt",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000000"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": "14",
          "stopbit": "12",
          "valueField": "010"
        }
      ],
      "definition": "rd = (capi_uint2int(rs1) < capi_uint2int(rs2)) ? 1 : 0;",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "slti",
      "type": "Logic",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "slti,INT-Reg,INT-Reg,inm-signed",
      "signatureRaw": "slti rd rs1 inm",
      "co": "0010011",
      "cop": "010",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "slti",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": "14",
          "stopbit": "12",
          "valueField": "010"
        }
      ],
      "definition": "rd = (capi_uint2int(rs1) < capi_uint2int(inm)) ? 1 : 0;",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "sltiu",
      "type": "Logic",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "sltiu,INT-Reg,INT-Reg,inm-signed",
      "signatureRaw": "sltiu rd rs1 inm",
      "co": "0010011",
      "cop": "011",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "sltiu",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": "14",
          "stopbit": "12",
          "valueField": "011"
        }
      ],
      "definition": "rd = (capi_int2uint(rs1) < capi_int2uint(inm)) ? 1 : 0;",
      "separated": [
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "sltu",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "sltu,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "sltu rd rs1 rs2",
      "co": "0110011",
      "cop": "0000000011",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "sltu",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "opcode",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000000"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": "14",
          "stopbit": "12",
          "valueField": "011"
        }
      ],
      "definition": "rd = ((rs1 >>> 0) < (rs2 >>> 0)) ? 1 : 0;",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "sra",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "sra,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "sra rd rs1 rs2",
      "co": "0110011",
      "cop": "0100000101",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "sra",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0100000"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "101"
        }
      ],
      "definition": "rd = capi_int2uint(rs1 >> rs2);",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "srai",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F1 F3 F4",
      "signature": "srai,INT-Reg,INT-Reg,inm-signed",
      "signatureRaw": "srai rd rs1 shamt",
      "co": "0010011",
      "cop": "010000101",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "srai",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "101"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "shamt",
          "type": "inm-signed",
          "startbit": 25,
          "stopbit": 20
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 26,
          "valueField": "010000"
        }
      ],
      "definition": "if (shamt > 0) {rd = capi_int2uint(rs1 >> shamt);}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "srl",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "srl,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "srl rd rs1 rs2",
      "co": "0110011",
      "cop": "0000000101",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "srl",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "opcode",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000000"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "101"
        }
      ],
      "definition": "rd = rs1 >> rs2;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "srli",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F1 F3 F4",
      "signature": "srli,INT-Reg,INT-Reg,inm-unsigned",
      "signatureRaw": "srli rd rs1 shamt",
      "co": "0010011",
      "cop": "000000101",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "srli",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "101"
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "shamt",
          "type": "inm-unsigned",
          "startbit": 25,
          "stopbit": 20
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 26,
          "valueField": "000000"
        }
      ],
      "definition": "if (shamt > 0) {rd = (rs1 >> shamt);}",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "sub",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "sub,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "sub rd rs1 rs2",
      "co": "0110011",
      "cop": "0100000000",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "sub",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0100000"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "000"
        }
      ],
      "definition": "rd = rs1 - rs2;",
      "separated": [
        false,
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "sw",
      "type": "Memory access",
      "signature_definition": "F0 F2 F1 (F3)",
      "signature": "sw,INT-Reg,inm-unsigned,(INT-Reg)",
      "signatureRaw": "sw rs2 inm (rs1)",
      "co": "0100011",
      "cop": "010",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "sw",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-unsigned",
          "startbit": [
            31,
            11
          ],
          "stopbit": [
            25,
            7
          ]
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "010"
        }
      ],
      "definition": "capi_mem_write(inm+rs1, rs2, 'w', rs2_name);",
      "separated": [
        false,
        true,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "xor",
      "type": "Arithmetic integer",
      "signature_definition": "F0 F4 F3 F2",
      "signature": "xor,INT-Reg,INT-Reg,INT-Reg",
      "signatureRaw": "xor rd rs1 rs2",
      "co": "0110011",
      "cop": "0000000100",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "xor",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "opcode",
          "type": "cop",
          "startbit": 31,
          "stopbit": 25,
          "valueField": "0000000"
        },
        {
          "name": "rs2",
          "type": "INT-Reg",
          "startbit": 24,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop2",
          "type": "cop",
          "startbit": "14",
          "stopbit": "12",
          "valueField": "100"
        }
      ],
      "definition": "rd = (rs1 ^ rs2);",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    },
    {
      "name": "xori",
      "type": "Logic",
      "signature_definition": "F0 F3 F2 F1",
      "signature": "xori,INT-Reg,INT-Reg,inm-signed",
      "signatureRaw": "xori rd rs1 inm",
      "co": "0010011",
      "cop": "100",
      "nwords": 1,
      "clk_cycles": 1,
      "fields": [
        {
          "name": "xori",
          "type": "co",
          "startbit": 6,
          "stopbit": 0
        },
        {
          "name": "inm",
          "type": "inm-signed",
          "startbit": 31,
          "stopbit": 20
        },
        {
          "name": "rs1",
          "type": "INT-Reg",
          "startbit": 19,
          "stopbit": 15
        },
        {
          "name": "rd",
          "type": "INT-Reg",
          "startbit": 11,
          "stopbit": 7
        },
        {
          "name": "cop",
          "type": "cop",
          "startbit": 14,
          "stopbit": 12,
          "valueField": "100"
        }
      ],
      "definition": "rd = rs1 ^ inm;",
      "separated": [
        false,
        false,
        false,
        false,
        false
      ],
      "help": ""
    }
  ],
  "pseudoinstructions": [
    {
      "name": "beqz",
      "signature_definition": "beqz F0 F1",
      "signature": "beqz,INT-Reg,offset_words",
      "signatureRaw": "beqz reg1 off",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "off",
          "type": "offset_words"
        }
      ],
      "definition": "beq reg1 x0 off;"
    },
    {
      "name": "bgez",
      "signature_definition": "bgez F0 F1",
      "signature": "bgez,INT-Reg,offset_words",
      "signatureRaw": "bgez reg1 off",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "off",
          "type": "offset_words"
        }
      ],
      "definition": "bge reg1 x0 off;"
    },
    {
      "name": "bgt",
      "signature_definition": "bgt F0 F1 F2",
      "signature": "bgt,INT-Reg,INT-Reg,offset_words",
      "signatureRaw": "bgt reg1 reg2 off",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "reg2",
          "type": "INT-Reg"
        },
        {
          "name": "off",
          "type": "offset_words"
        }
      ],
      "definition": "blt reg2 reg1 off;"
    },
    {
      "name": "bgtu",
      "signature_definition": "bgtu F0 F1 F2",
      "signature": "bgtu,INT-Reg,INT-Reg,offset_words",
      "signatureRaw": "bgtu reg1 reg2 off",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "reg2",
          "type": "INT-Reg"
        },
        {
          "name": "off",
          "type": "offset_words"
        }
      ],
      "definition": "bltu reg2 reg1 off;"
    },
    {
      "name": "bgtz",
      "signature_definition": "bgtz F0 F1",
      "signature": "bgtz,INT-Reg,offset_words",
      "signatureRaw": "bgtz reg1 off",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "off",
          "type": "offset_words"
        }
      ],
      "definition": "blt x0 reg1 off;"
    },
    {
      "name": "ble",
      "signature_definition": "ble F0 F1 F2",
      "signature": "ble,INT-Reg,INT-Reg,offset_words",
      "signatureRaw": "ble reg1 reg2 off",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "reg2",
          "type": "INT-Reg"
        },
        {
          "name": "off",
          "type": "offset_words"
        }
      ],
      "definition": "bge reg2 reg1 off;"
    },
    {
      "name": "bleu",
      "signature_definition": "bleu F0 F1 F2",
      "signature": "bleu,INT-Reg,INT-Reg,offset_words",
      "signatureRaw": "bleu reg1 reg2 off",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "reg2",
          "type": "INT-Reg"
        },
        {
          "name": "off",
          "type": "offset_words"
        }
      ],
      "definition": "bgeu reg2 reg1 off;"
    },
    {
      "name": "blez",
      "signature_definition": "blez F0 F1",
      "signature": "blez,INT-Reg,offset_words",
      "signatureRaw": "blez reg1 off",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "off",
          "type": "offset_words"
        }
      ],
      "definition": "bge x0 reg1 off;"
    },
    {
      "name": "bltz",
      "signature_definition": "bltz F0 F1",
      "signature": "bltz,INT-Reg,offset_words",
      "signatureRaw": "bltz reg1 off",
      "help": "Conditional branch if Rsrc1 is less than zero.",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg",
          "startbit": 25,
          "stopbit": 21
        },
        {
          "name": "off",
          "type": "offset_words",
          "startbit": 15,
          "stopbit": 0
        }
      ],
      "definition": "blt reg1 x0 off;"
    },
    {
      "name": "bnez",
      "signature_definition": "bnez F0 F1",
      "signature": "bnez,INT-Reg,offset_words",
      "signatureRaw": "bnez reg1 off",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "off",
          "type": "offset_words"
        }
      ],
      "definition": "bne reg1 x0 off;"
    },
    {
      "name": "fabs.d",
      "signature_definition": "fabs.d F0 F1",
      "signature": "fabs.d,DFP-Reg,DFP-Reg",
      "signatureRaw": "fabs.d reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "DFP-Reg"
        },
        {
          "name": "reg2",
          "type": "DFP-Reg"
        }
      ],
      "definition": "fsgnjx.d reg1 reg2 reg2;"
    },
    {
      "name": "fabs.s",
      "signature_definition": "fabs.s F0 F1",
      "signature": "fabs.s,SFP-Reg,SFP-Reg",
      "signatureRaw": "fabs.s reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "SFP-Reg"
        },
        {
          "name": "reg2",
          "type": "SFP-Reg"
        }
      ],
      "definition": "fsgnjx.s reg1 reg2 reg2;"
    },
    {
      "name": "fmv.d",
      "signature_definition": "fmv.d F0 F1",
      "signature": "fmv.d,DFP-Reg,DFP-Reg",
      "signatureRaw": "fmv.d reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "DFP-Reg"
        },
        {
          "name": "reg2",
          "type": "DFP-Reg"
        }
      ],
      "definition": "fsgnj.d reg1 reg2 reg2;"
    },
    {
      "name": "fmv.s",
      "signature_definition": "fmv.s F0 F1",
      "signature": "fmv.s,SFP-Reg,SFP-Reg",
      "signatureRaw": "fmv.s reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "SFP-Reg"
        },
        {
          "name": "reg2",
          "type": "SFP-Reg"
        }
      ],
      "definition": "fsgnj.s reg1 reg2 reg2;"
    },
    {
      "name": "fneg.d",
      "signature_definition": "fneg.d F0 F1",
      "signature": "fneg.d,DFP-Reg,DFP-Reg",
      "signatureRaw": "fneg.d reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "DFP-Reg"
        },
        {
          "name": "reg2",
          "type": "DFP-Reg"
        }
      ],
      "definition": "fsgnjn.d reg1 reg2 reg2;"
    },
    {
      "name": "fneg.s",
      "signature_definition": "fneg.s F0 F1",
      "signature": "fneg.s,SFP-Reg,SFP-Reg",
      "signatureRaw": "fneg.s reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "SFP-Reg"
        },
        {
          "name": "reg2",
          "type": "SFP-Reg"
        }
      ],
      "definition": "fsgnjn.s reg1 reg2 reg2;"
    },
    {
      "name": "j",
      "signature_definition": "j F0",
      "signature": "j,offset_words",
      "signatureRaw": "j off",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "off",
          "type": "offset_words"
        }
      ],
      "definition": "beq zero zero off;"
    },
    {
      "name": "jalr",
      "signature_definition": "jalr F0",
      "signature": "jalr,INT-Reg",
      "signatureRaw": "jalr rs",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "rs",
          "type": "INT-Reg"
        }
      ],
      "definition": "jalr x1 0 (rs);"
    },
    {
      "name": "jr",
      "signature_definition": "jr F0",
      "signature": "jr,INT-Reg",
      "signatureRaw": "jr rs",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "rs",
          "type": "INT-Reg"
        }
      ],
      "definition": "jalr x0 0 (rs);"
    },
    {
      "name": "la",
      "signature_definition": "la F0 F1",
      "signature": "la,INT-Reg,inm-unsigned",
      "signatureRaw": "la rd addr",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "rd",
          "type": "INT-Reg"
        },
        {
          "name": "addr",
          "type": "inm-unsigned"
        }
      ],
      "definition": "no_ret_op{tmp=Field.2.(31,0).int - reg.pc;\ntmp_hi='0x'+(((tmp&0xFFFFF000)>>12) + ((tmp&0x00000400)>>11)).toString(16);\ntmp_low='0x'+(tmp&0x00000FFF).toString(16)};\nauipc rd op{tmp_hi};\naddi rd rd op{tmp_low};"
    },
    {
      "name": "li",
      "signature_definition": "li F0 F1",
      "signature": "li,INT-Reg,inm-signed",
      "signatureRaw": "li rd val",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "rd",
          "type": "INT-Reg"
        },
        {
          "name": "val",
          "type": "inm-signed"
        }
      ],
      "definition": "if(Field.2.SIZE<=12){addi rd x0 val;}\nelse{lui rd 0;\nlui rd Field.2.(31,12).int;\naddi rd rd op{'0x'+(Field.2.(11,0).int ).toString(16)};}"
    },
    {
      "name": "mv",
      "signature_definition": "mv F0 F1",
      "signature": "mv,INT-Reg,INT-Reg",
      "signatureRaw": "mv reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "reg2",
          "type": "INT-Reg"
        }
      ],
      "definition": "addi reg1 reg2 0;"
    },
    {
      "name": "neg",
      "signature_definition": "neg F0 F1",
      "signature": "neg,INT-Reg,INT-Reg",
      "signatureRaw": "neg reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "reg2",
          "type": "INT-Reg"
        }
      ],
      "definition": "sub reg1 x0 reg2;"
    },
    {
      "name": "nop",
      "signature_definition": "nop",
      "signature": "nop",
      "signatureRaw": "nop",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [],
      "definition": "addi x0 x0 0;"
    },
    {
      "name": "not",
      "signature_definition": "not F0 F1",
      "signature": "not,INT-Reg,INT-Reg",
      "signatureRaw": "not reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "reg2",
          "type": "INT-Reg"
        }
      ],
      "definition": "xori reg1 reg2 -1;"
    },
    {
      "name": "ret",
      "signature_definition": "ret",
      "signature": "ret",
      "signatureRaw": "ret",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [],
      "definition": "jalr x0 0 (x1);"
    },
    {
      "name": "seqz",
      "signature_definition": "seqz F0 F1",
      "signature": "seqz,INT-Reg,INT-Reg",
      "signatureRaw": "seqz reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "reg2",
          "type": "INT-Reg"
        }
      ],
      "definition": "sltiu reg1 reg2 1;"
    },
    {
      "name": "sgtz",
      "signature_definition": "sgtz F0 F1",
      "signature": "sgtz,INT-Reg,INT-Reg",
      "signatureRaw": "sgtz reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "reg2",
          "type": "INT-Reg"
        }
      ],
      "definition": "slt reg1 x0 reg2;"
    },
    {
      "name": "sltz",
      "signature_definition": "sltz F0 F1",
      "signature": "sltz,INT-Reg,INT-Reg",
      "signatureRaw": "sltz reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "reg2",
          "type": "INT-Reg"
        }
      ],
      "definition": "slt reg1 reg2 x0;"
    },
    {
      "name": "snez",
      "signature_definition": "snez F0 F1",
      "signature": "snez,INT-Reg,INT-Reg",
      "signatureRaw": "snez reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "reg2",
          "type": "INT-Reg"
        }
      ],
      "definition": "sltu reg1 x0 reg2;"
    },
    {
      "name": "zext.b",
      "signature_definition": "zext.b F0 F1",
      "signature": "zext.b,INT-Reg,INT-Reg",
      "signatureRaw": "zext.b reg1 reg2",
      "help": "",
      "properties": [],
      "nwords": 1,
      "fields": [
        {
          "name": "reg1",
          "type": "INT-Reg"
        },
        {
          "name": "reg2",
          "type": "INT-Reg"
        }
      ],
      "definition": "andi reg1 reg2 255;"
    }
  ],
  "directives": [
    {
      "name": ".data",
      "action": "data_segment",
      "size": null
    },
    {
      "name": ".text",
      "action": "code_segment",
      "size": null
    },
    {
      "name": ".bss",
      "action": "global_symbol",
      "size": null
    },
    {
      "name": ".zero",
      "action": "space",
      "size": "1"
    },
    {
      "name": ".align",
      "action": "align",
      "size": null
    },
    {
      "name": ".balign",
      "action": "balign",
      "size": null
    },
    {
      "name": ".globl",
      "action": "global_symbol",
      "size": null
    },
    {
      "name": ".string",
      "action": "ascii_null_end",
      "size": null
    },
    {
      "name": ".byte",
      "action": "byte",
      "size": "1"
    },
    {
      "name": ".half",
      "action": "half_word",
      "size": "2"
    },
    {
      "name": ".word",
      "action": "word",
      "size": "4"
    },
    {
      "name": ".dword",
      "action": "double_word",
      "size": "8"
    },
    {
      "name": ".float",
      "action": "float",
      "size": "4"
    },
    {
      "name": ".double",
      "action": "double",
      "size": "8"
    }
  ],
  "memory_layout": [
    {
      "name": "text start",
      "value": "0x00000000"
    },
    {
      "name": "text end",
      "value": "0x001FFFFF"
    },
    {
      "name": "data start",
      "value": "0x00200000"
    },
    {
      "name": "data end",
      "value": "0x05BBFCBF"
    },
    {
      "name": "stack start",
      "value": "0x0FFFFFFC"
    },
    {
      "name": "stack end",
      "value": "0x0FFFFFFF"
    }
  ]
}